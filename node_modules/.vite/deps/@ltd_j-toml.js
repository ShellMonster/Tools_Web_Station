import {
  __require
} from "./chunk-2TUXWMP5.js";

// node_modules/@ltd/j-toml/index.mjs
var version = "1.38.0";
var SyntaxError$1 = SyntaxError;
var RangeError$1 = RangeError;
var TypeError$1 = TypeError;
var Error$1 = { if: Error }.if;
var undefined$1 = void 0;
var BigInt$1 = typeof BigInt === "undefined" ? undefined$1 : BigInt;
var RegExp$1 = RegExp;
var WeakMap$1 = WeakMap;
var get = WeakMap.prototype.get;
var set = WeakMap.prototype.set;
var create$1 = Object.create;
var isSafeInteger = Number.isSafeInteger;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var freeze = Object.freeze;
var isPrototypeOf = Object.prototype.isPrototypeOf;
var NULL = (
  /* j-globals: null.prototype (internal) */
  Object.seal ? Object.preventExtensions(/* @__PURE__ */ Object.create(null)) : null
);
var bind = Function.prototype.bind;
var test = RegExp.prototype.test;
var exec = RegExp.prototype.exec;
var apply$1 = Reflect.apply;
var Proxy$1 = Proxy;
var toStringTag = typeof Symbol === "undefined" ? undefined$1 : Symbol.toStringTag;
var Object_defineProperty = Object.defineProperty;
var assign$1 = Object.assign;
var Object$1 = Object;
var floor = Math.floor;
var isArray$1 = Array.isArray;
var Infinity = 1 / 0;
var fromCharCode = String.fromCharCode;
var Array$1 = Array;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propertyIsEnumerable = Object.prototype.propertyIsEnumerable;
var apply = Function.prototype.apply;
var isEnum = propertyIsEnumerable.call.bind(propertyIsEnumerable);
var hasOwn = (
  /* j-globals: Object.hasOwn (polyfill) */
  Object$1.hasOwn || (function() {
    return hasOwnProperty.bind ? hasOwnProperty.call.bind(hasOwnProperty) : function hasOwn2(object, key) {
      return hasOwnProperty.call(object, key);
    };
  })()
);
var create = Object$1.create;
function Descriptor(source) {
  var target = create(NULL);
  if (hasOwn(source, "value")) {
    target.value = source.value;
  }
  if (hasOwn(source, "writable")) {
    target.writable = source.writable;
  }
  if (hasOwn(source, "get")) {
    target.get = source.get;
  }
  if (hasOwn(source, "set")) {
    target.set = source.set;
  }
  if (hasOwn(source, "enumerable")) {
    target.enumerable = source.enumerable;
  }
  if (hasOwn(source, "configurable")) {
    target.configurable = source.configurable;
  }
  return target;
}
var Default = (
  /* j-globals: default (internal) */
  (function Default2(exports, addOnOrigin) {
    if (!addOnOrigin && typeof exports !== "function") {
      addOnOrigin = exports;
      exports = create$1(NULL);
    }
    if (assign$1) {
      assign$1(exports, addOnOrigin);
    } else {
      for (var key in addOnOrigin) {
        if (hasOwn(addOnOrigin, key)) {
          exports[key] = addOnOrigin[key];
        }
      }
    }
    exports.default = exports;
    if (typeof exports === "function") {
      exports.prototype && freeze(exports.prototype);
    } else if (toStringTag) {
      var descriptor = create$1(NULL);
      descriptor.value = "Module";
      Object_defineProperty(exports, toStringTag, descriptor);
    }
    return freeze(exports);
  })
);
var Test = bind ? bind.bind(test) : function(re) {
  return function(string) {
    return test.call(re, string);
  };
};
var Exec = bind ? bind.bind(exec) : function(re) {
  return function(string) {
    return exec.call(re, string);
  };
};
function __PURE__(re) {
  var test2 = re.test = Test(re);
  var exec2 = re.exec = Exec(re);
  var source = test2.source = exec2.source = re.source;
  test2.unicode = exec2.unicode = re.unicode;
  test2.ignoreCase = exec2.ignoreCase = re.ignoreCase;
  test2.multiline = exec2.multiline = source.indexOf("^") < 0 && source.indexOf("$") < 0 ? null : re.multiline;
  test2.dotAll = exec2.dotAll = source.indexOf(".") < 0 ? null : re.dotAll;
  return re;
}
function theRegExp(re) {
  return __PURE__(re);
}
var NT = /[\n\t]+/g;
var ESCAPE = /\\./g;
function graveAccentReplacer($$) {
  return $$ === "\\`" ? "`" : $$;
}
var includes = "".includes ? function(that, searchString) {
  return that.includes(searchString);
} : function(that, searchString) {
  return that.indexOf(searchString) > -1;
};
function RE(template) {
  var U = this.U;
  var I = this.I;
  var M = this.M;
  var S = this.S;
  var raw = template.raw;
  var source = raw[0].replace(NT, "");
  var index = 1;
  var length = arguments.length;
  while (index !== length) {
    var value = arguments[index];
    if (typeof value === "string") {
      source += value;
    } else {
      var value_source = value.source;
      if (typeof value_source !== "string") {
        throw TypeError$1("source");
      }
      if (value.unicode === U) {
        throw SyntaxError$1("unicode");
      }
      if (value.ignoreCase === I) {
        throw SyntaxError$1("ignoreCase");
      }
      if (value.multiline === M && (includes(value_source, "^") || includes(value_source, "$"))) {
        throw SyntaxError$1("multiline");
      }
      if (value.dotAll === S && includes(value_source, ".")) {
        throw SyntaxError$1("dotAll");
      }
      source += value_source;
    }
    source += raw[index++].replace(NT, "");
  }
  var re = RegExp$1(U ? source = source.replace(ESCAPE, graveAccentReplacer) : source, this.flags);
  var test2 = re.test = Test(re);
  var exec2 = re.exec = Exec(re);
  test2.source = exec2.source = source;
  test2.unicode = exec2.unicode = !U;
  test2.ignoreCase = exec2.ignoreCase = !I;
  test2.multiline = exec2.multiline = includes(source, "^") || includes(source, "$") ? !M : null;
  test2.dotAll = exec2.dotAll = includes(source, ".") ? !S : null;
  return re;
}
var RE_bind = bind && bind.bind(RE);
function Context(flags) {
  return {
    U: !includes(flags, "u"),
    I: !includes(flags, "i"),
    M: !includes(flags, "m"),
    S: !includes(flags, "s"),
    flags
  };
}
var CONTEXT = Context("");
var newRegExp = Proxy$1 ? new Proxy$1(RE, {
  apply: function(RE2, thisArg, args) {
    return apply$1(RE2, CONTEXT, args);
  },
  get: function(RE2, flags) {
    return RE_bind(Context(flags));
  },
  defineProperty: function() {
    return false;
  },
  preventExtensions: function() {
    return false;
  }
}) : (function() {
  RE.apply = RE.apply;
  var newRegExp2 = function() {
    return RE.apply(CONTEXT, arguments);
  };
  var d2 = 1;
  var g = d2 * 2;
  var i = g * 2;
  var m = i * 2;
  var s = i * 2;
  var u = s * 2;
  var y = u * 2;
  var flags = y * 2 - 1;
  while (flags--) {
    (function(context) {
      newRegExp2[context.flags] = function() {
        return RE.apply(context, arguments);
      };
    })(Context(
      (flags & d2 ? "" : "d") + (flags & g ? "" : "g") + (flags & i ? "" : "i") + (flags & m ? "" : "m") + (flags & s ? "" : "s") + (flags & u ? "" : "u") + (flags & y ? "" : "y")
    ));
  }
  return freeze ? freeze(newRegExp2) : newRegExp2;
})();
var clearRegExp = "$_" in RegExp$1 ? (function() {
  var REGEXP = /^/;
  REGEXP.test = REGEXP.test;
  return function clearRegExp3(value) {
    REGEXP.test("");
    return value;
  };
})() : function clearRegExp2(value) {
  return value;
};
var clearRegExp$1 = clearRegExp;
var NEED_TO_ESCAPE_IN_REGEXP = /^[$()*+\-.?[\\\]^{|]/;
var SURROGATE_PAIR = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/;
var GROUP = create$1(NULL);
function groupify(branches, uFlag, noEscape) {
  var group = create$1(NULL);
  var appendBranch = uFlag ? appendPointBranch : appendCodeBranch;
  for (var length = branches.length, index = 0; index < length; ++index) {
    appendBranch(group, branches[index]);
  }
  return sourcify(group, !noEscape);
}
function appendPointBranch(group, branch) {
  if (branch) {
    var character = SURROGATE_PAIR.test(branch) ? branch.slice(0, 2) : branch.charAt(0);
    appendPointBranch(group[character] || (group[character] = create$1(NULL)), branch.slice(character.length));
  } else {
    group[""] = GROUP;
  }
}
function appendCodeBranch(group, branch) {
  if (branch) {
    var character = branch.charAt(0);
    appendCodeBranch(group[character] || (group[character] = create$1(NULL)), branch.slice(1));
  } else {
    group[""] = GROUP;
  }
}
function sourcify(group, needEscape) {
  var branches = [];
  var singleCharactersBranch = [];
  var noEmptyBranch = true;
  for (var character in group) {
    if (character) {
      var sub_branches = sourcify(group[character], needEscape);
      if (needEscape && NEED_TO_ESCAPE_IN_REGEXP.test(character)) {
        character = "\\" + character;
      }
      sub_branches ? branches.push(character + sub_branches) : singleCharactersBranch.push(character);
    } else {
      noEmptyBranch = false;
    }
  }
  singleCharactersBranch.length && branches.unshift(singleCharactersBranch.length === 1 ? singleCharactersBranch[0] : "[" + singleCharactersBranch.join("") + "]");
  return branches.length === 0 ? "" : (branches.length === 1 && (singleCharactersBranch.length || noEmptyBranch) ? branches[0] : "(?:" + branches.join("|") + ")") + (noEmptyBranch ? "" : "?");
}
var WeakSet$1 = WeakSet;
var has = WeakSet.prototype.has;
var add = WeakSet.prototype.add;
var del = WeakSet.prototype["delete"];
var keys = Object.keys;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var Null$1 = (
  /* j-globals: null (internal) */
  (function() {
    var assign2 = Object.assign || function assign3(target, source) {
      var keys$1, index, key;
      for (keys$1 = keys(source), index = 0; index < keys$1.length; ++index) {
        key = keys$1[index];
        target[key] = source[key];
      }
      if (getOwnPropertySymbols) {
        for (keys$1 = getOwnPropertySymbols(source), index = 0; index < keys$1.length; ++index) {
          key = keys$1[index];
          if (isEnum(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    function Nullify(constructor) {
      delete constructor.prototype.constructor;
      freeze(constructor.prototype);
      return constructor;
    }
    function Null2(origin) {
      return origin === undefined$1 ? this : typeof origin === "function" ? Nullify(origin) : assign2(create(NULL), origin);
    }
    delete Null2.name;
    Null2.prototype = null;
    freeze(Null2);
    return Null2;
  })()
);
var is = Object.is;
var Object_defineProperties = Object.defineProperties;
var fromEntries = Object.fromEntries;
var Reflect_construct = Reflect.construct;
var Reflect_defineProperty = Reflect.defineProperty;
var Reflect_deleteProperty = Reflect.deleteProperty;
var ownKeys = Reflect.ownKeys;
var Keeper = () => [];
var newWeakMap = () => {
  const weakMap = new WeakMap$1();
  weakMap.has = weakMap.has;
  weakMap.get = weakMap.get;
  weakMap.set = weakMap.set;
  return weakMap;
};
var target2keeper = newWeakMap();
var proxy2target = newWeakMap();
var target2proxy = newWeakMap();
var handlers = assign$1(create$1(NULL), {
  defineProperty: (target, key, descriptor) => {
    if (hasOwn(target, key)) {
      return Reflect_defineProperty(target, key, assign$1(create$1(NULL), descriptor));
    }
    if (Reflect_defineProperty(target, key, assign$1(create$1(NULL), descriptor))) {
      const keeper = target2keeper.get(target);
      keeper[keeper.length] = key;
      return true;
    }
    return false;
  },
  deleteProperty: (target, key) => {
    if (Reflect_deleteProperty(target, key)) {
      const keeper = target2keeper.get(target);
      const index = keeper.indexOf(key);
      index < 0 || --keeper.copyWithin(index, index + 1).length;
      return true;
    }
    return false;
  },
  ownKeys: (target) => target2keeper.get(target),
  construct: (target, args, newTarget) => orderify(Reflect_construct(target, args, newTarget)),
  apply: (target, thisArg, args) => orderify(apply$1(target, thisArg, args))
});
var newProxy = (target, keeper) => {
  target2keeper.set(target, keeper);
  const proxy = new Proxy$1(target, handlers);
  proxy2target.set(proxy, target);
  return proxy;
};
var orderify = (object) => {
  if (proxy2target.has(object)) {
    return object;
  }
  let proxy = target2proxy.get(object);
  if (proxy) {
    return proxy;
  }
  proxy = newProxy(object, assign$1(Keeper(), ownKeys(object)));
  target2proxy.set(object, proxy);
  return proxy;
};
var Null = (function() {
  function throwConstructing() {
    throw TypeError$1(`Super constructor Null cannot be invoked with 'new'`);
  }
  function throwApplying() {
    throw TypeError$1(`Super constructor Null cannot be invoked without 'new'`);
  }
  const Nullify = (constructor) => {
    delete constructor.prototype.constructor;
    freeze(constructor.prototype);
    return constructor;
  };
  function Null2(constructor) {
    return new.target ? new.target === Null2 ? throwConstructing() : newProxy(this, Keeper()) : typeof constructor === "function" ? Nullify(constructor) : throwApplying();
  }
  Null2.prototype = null;
  Object_defineProperty(Null2, "name", assign$1(create$1(NULL), { value: "", configurable: false }));
  freeze(Null2);
  return Null2;
})();
var map_has = WeakMap.prototype.has;
var map_del = WeakMap.prototype["delete"];
var INLINES = new WeakMap$1();
var SECTIONS = new WeakSet$1();
var deInline = map_del.bind(INLINES);
var deSection = del.bind(SECTIONS);
var isInline = map_has.bind(INLINES);
var ofInline = get.bind(INLINES);
var beInline = set.bind(INLINES);
var inline = (value, mode, looping) => {
  if (isArray$1(value)) {
    if (looping) {
      mode = 3;
    } else {
      if (mode === undefined$1) {
        mode = 3;
      } else if (mode !== 0 && mode !== 1 && mode !== 2 && mode !== 3) {
        throw typeof mode === "number" ? RangeError$1(`array inline mode must be 0 | 1 | 2 | 3, not including ${mode}`) : TypeError$1(`array inline mode must be "number" type, not including ${mode === null ? '"null"' : typeof mode}`);
      }
    }
    beInline(value, mode);
  } else {
    beInline(value, true);
    deSection(value);
  }
  return value;
};
var multilineTable = (value) => {
  beInline(value, false);
  deSection(value);
  return value;
};
var multilineArray = (value) => {
  deInline(value);
  return value;
};
var isSection = has.bind(SECTIONS);
var beSection = add.bind(SECTIONS);
var Section = (table) => {
  if (isArray$1(table)) {
    throw TypeError$1(`array can not be section, maybe you want to use it on the tables in it`);
  }
  beSection(table);
  deInline(table);
  return table;
};
var INLINE = true;
var tables = new WeakSet$1();
var tables_add = add.bind(tables);
var isTable = has.bind(tables);
var implicitTables = new WeakSet$1();
var implicitTables_add = add.bind(implicitTables);
var implicitTables_del = del.bind(implicitTables);
var directlyIfNot = (table) => {
  if (implicitTables_del(table)) {
    beSection(table);
    return true;
  }
  return false;
};
var DIRECTLY = true;
var IMPLICITLY = false;
var pairs = new WeakSet$1();
var pairs_add = add.bind(pairs);
var fromPair = has.bind(pairs);
var PAIR = true;
var PlainTable = Null$1(class Table extends Null$1 {
  constructor(isDirect, isInline$fromPair) {
    super();
    tables_add(this);
    isDirect ? isInline$fromPair ? beInline(this, true) : beSection(this) : (isInline$fromPair ? pairs_add : implicitTables_add)(this);
    return this;
  }
});
var OrderedTable = Null$1(class Table2 extends Null {
  constructor(isDirect, isInline$fromPair) {
    super();
    tables_add(this);
    isDirect ? isInline$fromPair ? beInline(this, true) : beSection(this) : (isInline$fromPair ? pairs_add : implicitTables_add)(this);
    return this;
  }
});
var NONE = [];
var sourcePath = "";
var sourceLines = NONE;
var lastLineIndex = -1;
var lineIndex = -1;
var throws = (error) => {
  throw error;
};
var EOL = /\r?\n/;
var todo = (source, path) => {
  if (typeof path !== "string") {
    throw TypeError$1(`TOML.parse({ path })`);
  }
  sourcePath = path;
  sourceLines = source.split(EOL);
  lastLineIndex = sourceLines.length - 1;
  lineIndex = -1;
};
var next = () => sourceLines[++lineIndex];
var rest = () => lineIndex !== lastLineIndex;
var mark = class {
  lineIndex = lineIndex;
  type;
  restColumn;
  constructor(type, restColumn) {
    this.type = type;
    this.restColumn = restColumn;
    return this;
  }
  must() {
    lineIndex === lastLineIndex && throws(SyntaxError$1(`${this.type} is not close until the end of the file` + where(", which started from ", this.lineIndex, sourceLines[this.lineIndex].length - this.restColumn + 1)));
    return sourceLines[++lineIndex];
  }
  nowrap(argsMode) {
    throw throws(Error$1(`TOML.parse(${argsMode ? `${argsMode}multilineStringJoiner` : `,{ joiner }`}) must be passed, while the source including multi-line string` + where(", which started from ", this.lineIndex, sourceLines[this.lineIndex].length - this.restColumn + 1)));
  }
};
var where = (pre, rowIndex = lineIndex, columnNumber = 0) => sourceLines === NONE ? "" : sourcePath ? `
    at (${sourcePath}:${rowIndex + 1}:${columnNumber})` : `${pre}line ${rowIndex + 1}: ${sourceLines[rowIndex]}`;
var done = () => {
  sourcePath = "";
  sourceLines = NONE;
};
var Whitespace = /[ \t]/;
var PRE_WHITESPACE = newRegExp`
	^${Whitespace}+`.valueOf();
var { exec: VALUE_REST_exec } = newRegExp.s`
	^
	(
		(?:\d\d\d\d-\d\d-\d\d \d)?
		[\w\-+.:]+
	)
	${Whitespace}*
	(.*)
	$`.valueOf();
var { exec: LITERAL_STRING_exec } = newRegExp.s`
	^
	'([^']*)'
	${Whitespace}*
	(.*)`.valueOf();
var { exec: MULTI_LINE_LITERAL_STRING_0_1_2 } = newRegExp.s`
	^
	(.*?)
	'''('{0,2})
	${Whitespace}*
	(.*)`.valueOf();
var { exec: MULTI_LINE_LITERAL_STRING_0 } = newRegExp.s`
	^
	(.*?)
	'''()
	${Whitespace}*
	(.*)`.valueOf();
var __MULTI_LINE_LITERAL_STRING_exec = MULTI_LINE_LITERAL_STRING_0;
var SYM_WHITESPACE = newRegExp.s`
	^
	.
	${Whitespace}*`.valueOf();
var Tag = /[^\x00-\x1F"#'()<>[\\\]`{}\x7F]+/;
var { exec: KEY_VALUE_PAIR_exec } = newRegExp.s`
	^
	${Whitespace}*
	=
	${Whitespace}*
	(?:
		<(${Tag})>
		${Whitespace}*
	)?
	(.*)
	$`.valueOf();
var { exec: _VALUE_PAIR_exec } = newRegExp.s`
	^
	<(${Tag})>
	${Whitespace}*
	(.*)
	$`.valueOf();
var { exec: TAG_REST_exec } = newRegExp.s`
	^
	<(${Tag})>
	${Whitespace}*
	(.*)
	$`.valueOf();
var MULTI_LINE_BASIC_STRING = theRegExp(/[^\\"]+|\\.?|"(?!"")"?/sy);
var MULTI_LINE_BASIC_STRING_exec_0_length = (_) => {
  let lastIndex = (
    /*MULTI_LINE_BASIC_STRING.lastIndex = */
    0
  );
  while (MULTI_LINE_BASIC_STRING.test(_)) {
    lastIndex = MULTI_LINE_BASIC_STRING.lastIndex;
  }
  return lastIndex;
};
var ESCAPED_EXCLUDE_CONTROL_CHARACTER_TAB______ = /[^\\\x00-\x08\x0B-\x1F\x7F]+|\\(?:[btnfr"\\]|[\t ]*\n[\t\n ]*|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/g;
var ESCAPED_EXCLUDE_CONTROL_CHARACTER__________ = /[^\\\x00-\x09\x0B-\x1F\x7F]+|\\(?:[btnfr"\\]|[\t ]*\n[\t\n ]*|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/g;
var ESCAPED_EXCLUDE_CONTROL_CHARACTER_DEL______ = /[^\\\x00-\x09\x0B-\x1F]+|\\(?:[btnfr"\\]|[\t ]*\n[\t\n ]*|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/g;
var ESCAPED_EXCLUDE_CONTROL_CHARACTER_DEL_SLASH = /[^\\\x00-\x09\x0B-\x1F]+|\\(?:[btnfr"\\/]|[\t ]*\n[\t\n ]*|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/g;
var __ESCAPED_EXCLUDE_CONTROL_CHARACTER = ESCAPED_EXCLUDE_CONTROL_CHARACTER_TAB______;
var ESCAPED_EXCLUDE_CONTROL_CHARACTER_test = (_) => !_.replace(__ESCAPED_EXCLUDE_CONTROL_CHARACTER, "");
var BASIC_STRING_TAB______ = theRegExp(/[^\\"\x00-\x08\x0B-\x1F\x7F]+|\\(?:[btnfr"\\]|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/y);
var BASIC_STRING__________ = theRegExp(/[^\\"\x00-\x08\x0B-\x1F\x7F]+|\\(?:[btnfr"\\]|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/y);
var BASIC_STRING_DEL______ = theRegExp(/[^\\"\x00-\x08\x0B-\x1F]+|\\(?:[btnfr"\\]|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/y);
var BASIC_STRING_DEL_SLASH = theRegExp(/[^\\"\x00-\x08\x0B-\x1F]+|\\(?:[btnfr"\\/]|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/y);
var __BASIC_STRING = BASIC_STRING_DEL_SLASH;
var BASIC_STRING_exec_1_endIndex = (line) => {
  let lastIndex = __BASIC_STRING.lastIndex = 1;
  while (__BASIC_STRING.test(line)) {
    lastIndex = __BASIC_STRING.lastIndex;
  }
  lastIndex !== line.length && line[lastIndex] === '"' || throws(SyntaxError$1(`Bad basic string` + where(" at ")));
  return lastIndex;
};
var { test: IS_DOT_KEY } = theRegExp(/^[ \t]*\./);
var DOT_KEY = /^[ \t]*\.[ \t]*/;
var { exec: BARE_KEY_STRICT } = theRegExp(/^[\w-]+/);
var { exec: BARE_KEY_FREE } = theRegExp(/^[^ \t#=[\]'".]+(?:[ \t]+[^ \t#=[\]'".]+)*/);
var __BARE_KEY_exec = BARE_KEY_FREE;
var { exec: LITERAL_KEY____ } = theRegExp(/^'[^'\x00-\x08\x0B-\x1F\x7F]*'/);
var { exec: LITERAL_KEY_DEL } = theRegExp(/^'[^'\x00-\x08\x0B-\x1F]*'/);
var __LITERAL_KEY_exec = LITERAL_KEY_DEL;
var supportArrayOfTables = true;
var TABLE_DEFINITION_exec_groups = (lineRest, parseKeys2) => {
  const asArrayItem = lineRest[1] === "[";
  if (asArrayItem) {
    supportArrayOfTables || throws(SyntaxError$1(`Array of Tables is not allowed before TOML v0.2` + where(", which at ")));
    lineRest = lineRest.slice(2);
  } else {
    lineRest = lineRest.slice(1);
  }
  lineRest = lineRest.replace(PRE_WHITESPACE, "");
  const { leadingKeys, finalKey } = { lineRest } = parseKeys2(lineRest);
  lineRest = lineRest.replace(PRE_WHITESPACE, "");
  lineRest && lineRest[0] === "]" || throws(SyntaxError$1(`Table header is not closed` + where(", which is found at ")));
  (lineRest.length > 1 ? lineRest[1] === "]" === asArrayItem : !asArrayItem) || throws(SyntaxError$1(`Square brackets of Table definition statement not match` + where(" at ")));
  lineRest = lineRest.slice(asArrayItem ? 2 : 1).replace(PRE_WHITESPACE, "");
  let tag;
  if (lineRest && lineRest[0] === "<") {
    ({ 1: tag, 2: lineRest } = TAG_REST_exec(lineRest) || throws(SyntaxError$1(`Bad tag` + where(" at "))));
  } else {
    tag = "";
  }
  return { leadingKeys, finalKey, asArrayItem, tag, lineRest };
};
var KEY_VALUE_PAIR_exec_groups = ({ leadingKeys, finalKey, lineRest }) => {
  const { 1: tag = "" } = { 2: lineRest } = KEY_VALUE_PAIR_exec(lineRest) || throws(SyntaxError$1(`Keys must equal something` + where(", but missing at ")));
  tag || lineRest && lineRest[0] !== "#" || throws(SyntaxError$1(`Value can not be missing after euqal sign` + where(", which is found at ")));
  return { leadingKeys, finalKey, tag, lineRest };
};
var { test: CONTROL_CHARACTER_EXCLUDE_TAB____ } = theRegExp(/[\x00-\x08\x0B-\x1F\x7F]/);
var { test: CONTROL_CHARACTER_EXCLUDE_TAB_DEL } = theRegExp(/[\x00-\x08\x0B-\x1F]/);
var __CONTROL_CHARACTER_EXCLUDE_test = CONTROL_CHARACTER_EXCLUDE_TAB____;
var switchRegExp = (specificationVersion) => {
  switch (specificationVersion) {
    case 1:
      __MULTI_LINE_LITERAL_STRING_exec = MULTI_LINE_LITERAL_STRING_0_1_2;
      __LITERAL_KEY_exec = LITERAL_KEY____;
      __CONTROL_CHARACTER_EXCLUDE_test = CONTROL_CHARACTER_EXCLUDE_TAB____;
      __ESCAPED_EXCLUDE_CONTROL_CHARACTER = ESCAPED_EXCLUDE_CONTROL_CHARACTER_TAB______;
      __BASIC_STRING = BASIC_STRING_TAB______;
      __BARE_KEY_exec = BARE_KEY_STRICT;
      supportArrayOfTables = true;
      break;
    case 0.5:
      __MULTI_LINE_LITERAL_STRING_exec = MULTI_LINE_LITERAL_STRING_0;
      __LITERAL_KEY_exec = LITERAL_KEY____;
      __CONTROL_CHARACTER_EXCLUDE_test = CONTROL_CHARACTER_EXCLUDE_TAB____;
      __ESCAPED_EXCLUDE_CONTROL_CHARACTER = ESCAPED_EXCLUDE_CONTROL_CHARACTER__________;
      __BASIC_STRING = BASIC_STRING__________;
      __BARE_KEY_exec = BARE_KEY_STRICT;
      supportArrayOfTables = true;
      break;
    case 0.4:
      __MULTI_LINE_LITERAL_STRING_exec = MULTI_LINE_LITERAL_STRING_0;
      __LITERAL_KEY_exec = LITERAL_KEY_DEL;
      __CONTROL_CHARACTER_EXCLUDE_test = CONTROL_CHARACTER_EXCLUDE_TAB_DEL;
      __ESCAPED_EXCLUDE_CONTROL_CHARACTER = ESCAPED_EXCLUDE_CONTROL_CHARACTER_DEL______;
      __BASIC_STRING = BASIC_STRING_DEL______;
      __BARE_KEY_exec = BARE_KEY_STRICT;
      supportArrayOfTables = true;
      break;
    default:
      __MULTI_LINE_LITERAL_STRING_exec = MULTI_LINE_LITERAL_STRING_0;
      __LITERAL_KEY_exec = LITERAL_KEY_DEL;
      __CONTROL_CHARACTER_EXCLUDE_test = CONTROL_CHARACTER_EXCLUDE_TAB_DEL;
      __ESCAPED_EXCLUDE_CONTROL_CHARACTER = ESCAPED_EXCLUDE_CONTROL_CHARACTER_DEL_SLASH;
      __BASIC_STRING = BASIC_STRING_DEL_SLASH;
      __BARE_KEY_exec = BARE_KEY_FREE;
      supportArrayOfTables = false;
  }
};
var NUM = newRegExp`
	(?:
		0
		(?:
			b[01][_01]*
		|
			o[0-7][_0-7]*
		|
			x[\dA-Fa-f][_\dA-Fa-f]*
		|
			(?:\.\d[_\d]*)?(?:[Ee]-?\d[_\d]*)?
		)
	|
		[1-9][_\d]*
		(?:\.\d[_\d]*)?(?:[Ee]-?\d[_\d]*)?
	|
		inf
	|
		nan
	)
`.valueOf();
var { test: IS_AMAZING } = newRegExp`
	^(?:
		-?${NUM}
		(?:-${NUM})*
	|
		true
	|
		false
	)$
`.valueOf();
var { test: BAD_DXOB } = newRegExp`_(?![\dA-Fa-f])`.valueOf();
var isAmazing = (keys2) => IS_AMAZING(keys2) && !BAD_DXOB(keys2);
var mustScalar = true;
var ARGS_MODE = "";
var useWhatToJoinMultilineString = null;
var usingBigInt = true;
var IntegerMinNumber = 0;
var IntegerMaxNumber = 0;
var ANY = {
  test: () => true
};
var Keys = class KeysRegExp extends RegExp$1 {
  constructor(keys2) {
    super(`^${groupify(keys2)}$`);
    let maxLength = -1;
    for (let index = keys2.length; index; ) {
      const { length } = keys2[--index];
      if (length > maxLength) {
        maxLength = length;
      }
    }
    this.lastIndex = maxLength + 1;
    return this;
  }
  test(key) {
    return key.length < this.lastIndex && super.test(key);
  }
};
var isKeys = isPrototypeOf.bind(freeze(Keys.prototype));
var KEYS$1 = ANY;
var preserveLiteral;
var zeroDatetime;
var inlineTable;
var moreDatetime;
var disallowEmptyKey;
var sError;
var sFloat;
var Table3;
var allowLonger;
var enableNull;
var allowInlineTableMultilineAndTrailingCommaEvenNoComma;
var preserveComment;
var disableDigit;
var arrayTypes = new WeakMap$1();
var arrayTypes_get = get.bind(arrayTypes);
var arrayTypes_set = set.bind(arrayTypes);
var As = () => {
  const as = (array) => {
    const got = arrayTypes_get(array);
    got ? got === as || throws(TypeError$1(`Types in Array must be same` + where(". Check "))) : arrayTypes_set(array, as);
    return array;
  };
  return as;
};
var AS_TYPED = {
  asNulls: As(),
  asStrings: As(),
  asTables: As(),
  asArrays: As(),
  asBooleans: As(),
  asFloats: As(),
  asIntegers: As(),
  asOffsetDateTimes: As(),
  asLocalDateTimes: As(),
  asLocalDates: As(),
  asLocalTimes: As()
};
var asMixed = (array) => array;
var asNulls;
var asStrings;
var asTables;
var asArrays;
var asBooleans;
var asFloats;
var asIntegers;
var asOffsetDateTimes;
var asLocalDateTimes;
var asLocalDates;
var asLocalTimes;
var processor = null;
var each = null;
var collect_on = (tag, array, table, key) => {
  const _each = create$1(NULL);
  _each._linked = each;
  _each.tag = tag;
  if (table) {
    _each.table = table;
    _each.key = key;
  }
  if (array) {
    _each.array = array;
    _each.index = array.length;
  }
  each = _each;
};
var collect_off = () => {
  throw throws(SyntaxError$1(`xOptions.tag is not enabled, but found tag syntax` + where(" at ")));
};
var collect = collect_off;
var Process = () => {
  if (each) {
    const _processor = processor;
    let _each = each;
    each = null;
    return () => {
      const processor2 = _processor;
      let each2 = _each;
      _each = null;
      do {
        processor2(each2);
      } while (each2 = each2._linked);
    };
  }
  return null;
};
var clear = () => {
  KEYS$1 = ANY;
  useWhatToJoinMultilineString = processor = each = null;
  zeroDatetime = false;
};
var use = (specificationVersion, multilineStringJoiner, useBigInt, keys2, xOptions, argsMode) => {
  ARGS_MODE = argsMode;
  let mixed;
  switch (specificationVersion) {
    case 1:
      mustScalar = mixed = moreDatetime = sFloat = inlineTable = true;
      zeroDatetime = disallowEmptyKey = false;
      break;
    case 0.5:
      mustScalar = moreDatetime = sFloat = inlineTable = true;
      mixed = zeroDatetime = disallowEmptyKey = false;
      break;
    case 0.4:
      mustScalar = disallowEmptyKey = inlineTable = true;
      mixed = zeroDatetime = moreDatetime = sFloat = false;
      break;
    case 0.3:
      mustScalar = disallowEmptyKey = true;
      mixed = zeroDatetime = moreDatetime = sFloat = inlineTable = false;
      break;
    case 0.2:
      zeroDatetime = disallowEmptyKey = true;
      mustScalar = mixed = moreDatetime = sFloat = inlineTable = false;
      break;
    case 0.1:
      zeroDatetime = disallowEmptyKey = true;
      mustScalar = mixed = moreDatetime = sFloat = inlineTable = false;
      break;
    default:
      throw RangeError$1(`TOML.parse(,specificationVersion)`);
  }
  switchRegExp(specificationVersion);
  if (typeof multilineStringJoiner === "string") {
    useWhatToJoinMultilineString = multilineStringJoiner;
  } else if (multilineStringJoiner === undefined$1) {
    useWhatToJoinMultilineString = null;
  } else {
    throw TypeError$1(`TOML.parse(${ARGS_MODE ? `${ARGS_MODE}multilineStringJoiner` : `,{ joiner }`})`);
  }
  if (useBigInt === undefined$1 || useBigInt === true) {
    usingBigInt = true;
  } else if (useBigInt === false) {
    usingBigInt = false;
  } else {
    if (typeof useBigInt !== "number") {
      throw TypeError$1(`TOML.parse(${ARGS_MODE ? `${ARGS_MODE},useBigInt` : `,{ bigint }`})`);
    }
    if (!isSafeInteger(useBigInt)) {
      throw RangeError$1(`TOML.parse(${ARGS_MODE ? `${ARGS_MODE},useBigInt` : `,{ bigint }`})`);
    }
    usingBigInt = null;
    useBigInt >= 0 ? IntegerMinNumber = -(IntegerMaxNumber = useBigInt) : IntegerMaxNumber = -(IntegerMinNumber = useBigInt) - 1;
  }
  if (!BigInt$1 && usingBigInt !== false) {
    throw Error$1(`Can't work without TOML.parse(${ARGS_MODE ? `${ARGS_MODE},useBigInt` : `,{ bigint }`}) being set to false, because the host doesn't have BigInt support`);
  }
  if (keys2 == null) {
    KEYS$1 = ANY;
  } else {
    if (!isKeys(keys2)) {
      throw TypeError$1(`TOML.parse(,{ keys })`);
    }
    KEYS$1 = keys2;
  }
  if (xOptions == null) {
    Table3 = PlainTable;
    sError = allowLonger = enableNull = allowInlineTableMultilineAndTrailingCommaEvenNoComma = false;
    collect = collect_off;
  } else if (typeof xOptions !== "object") {
    throw TypeError$1(`TOML.parse(${ARGS_MODE ? `${ARGS_MODE},,xOptions` : `,{ x }`})`);
  } else {
    const { order, longer, exact, null: _null, multi, comment, string, literal: literal2, tag, ...unknown } = xOptions;
    const unknownNames = getOwnPropertyNames(unknown);
    if (unknownNames.length) {
      throw TypeError$1(`TOML.parse(${ARGS_MODE ? `${ARGS_MODE},,{ ${unknownNames.join(", ")} }` : `,{ x: { ${unknownNames.join(", ")} } }`})`);
    }
    Table3 = order ? OrderedTable : PlainTable;
    allowLonger = !longer;
    sError = !!exact;
    enableNull = !!_null;
    allowInlineTableMultilineAndTrailingCommaEvenNoComma = !!multi;
    preserveComment = !!comment;
    disableDigit = !!string;
    preserveLiteral = !!literal2;
    if (tag) {
      if (typeof tag !== "function") {
        throw TypeError$1(`TOML.parse(${ARGS_MODE ? `${ARGS_MODE},,{ tag }` : `,{ x: { tag } }`})`);
      }
      if (!mixed) {
        throw TypeError$1(`TOML.parse(${ARGS_MODE ? `${ARGS_MODE},,xOptions` : `,{ x }`}) xOptions.tag needs at least TOML 1.0 to support mixed type array`);
      }
      processor = tag;
      collect = collect_on;
    } else {
      collect = collect_off;
    }
  }
  mixed ? asNulls = asStrings = asTables = asArrays = asBooleans = asFloats = asIntegers = asOffsetDateTimes = asLocalDateTimes = asLocalDates = asLocalTimes = asMixed : { asNulls, asStrings, asTables, asArrays, asBooleans, asFloats, asIntegers, asOffsetDateTimes, asLocalDateTimes, asLocalDates, asLocalTimes } = AS_TYPED;
};
var isView = ArrayBuffer.isView;
var isArrayBuffer = (
  /* j-globals: class.isArrayBuffer (internal) */
  (function() {
    if (typeof ArrayBuffer === "function") {
      var byteLength_apply = apply.bind(Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get);
      return function isArrayBuffer2(value) {
        try {
          byteLength_apply(value);
        } catch (error) {
          return false;
        }
        return true;
      };
    }
    return function isArrayBuffer2() {
      return false;
    };
  })()
);
var TextDecoder$1 = TextDecoder;
var Symbol$1 = Symbol;
var previous = Symbol$1("previous");
var x = (rootStack) => {
  let stack = rootStack;
  let result = stack.next();
  if (!result.done) {
    result.value[previous] = stack;
    result = (stack = result.value).next();
    for (; ; ) {
      if (result.done) {
        if (stack === rootStack) {
          break;
        }
        stack = stack[previous];
        result = stack.next(result.value);
      } else {
        result.value[previous] = stack;
        result = (stack = result.value).next();
      }
    }
  }
  return result.value;
};
var _literal = Symbol$1("_literal");
var LiteralObject = (literal2, value) => {
  const object = Object$1(value);
  object[_literal] = literal2;
  return object;
};
var arrays = new WeakSet$1();
var arrays_add = add.bind(arrays);
var isArray = has.bind(arrays);
var OF_TABLES = false;
var STATICALLY = true;
var staticalArrays = new WeakSet$1();
var staticalArrays_add = add.bind(staticalArrays);
var isStatic = has.bind(staticalArrays);
var newArray = (isStatic2) => {
  const array = [];
  arrays_add(array);
  isStatic2 && staticalArrays_add(array);
  return array;
};
var NativeDate = Date;
var parse$2 = Date.parse;
var preventExtensions = Object.preventExtensions;
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors;
var defineProperties = (
  /* j-globals: null.defineProperties (internal) */
  (function defineProperties2(object, descriptorMap) {
    var created = create$1(NULL);
    var names = keys(descriptorMap);
    for (var length = names.length, index = 0; index < length; ++index) {
      var name = names[index];
      created[name] = Descriptor(descriptorMap[name]);
    }
    if (getOwnPropertySymbols) {
      var symbols = getOwnPropertySymbols(descriptorMap);
      for (length = symbols.length, index = 0; index < length; ++index) {
        var symbol = symbols[index];
        if (isEnum(descriptorMap, symbol)) {
          created[symbol] = Descriptor(descriptorMap[symbol]);
        }
      }
    }
    return Object_defineProperties(object, created);
  })
);
var fpc = (c) => {
  freeze(freeze(c).prototype);
  return c;
};
var _29_ = /(?:0[1-9]|1\d|2\d)/;
var _30_ = /(?:0[1-9]|[12]\d|30)/;
var _31_ = /(?:0[1-9]|[12]\d|3[01])/;
var _23_ = /(?:[01]\d|2[0-3])/;
var _59_ = /[0-5]\d/;
var YMD = newRegExp`
	\d\d\d\d-
	(?:
		0
		(?:
			[13578]-${_31_}
			|
			[469]-${_30_}
			|
			2-${_29_}
		)
		|
		1
		(?:
			[02]-${_31_}
			|
			1-${_30_}
		)
	)
`.valueOf();
var HMS = newRegExp`
	${_23_}:${_59_}:${_59_}
`.valueOf();
var OFFSET$ = /(?:[Zz]|[+-]\d\d:\d\d)$/;
var { exec: Z_exec } = theRegExp(/(([+-])\d\d):(\d\d)$/);
var { exec: OFFSET_DATETIME_exec } = newRegExp`
	^
	${YMD}
	[Tt ]
	${HMS}
	(?:\.\d{1,3}(\d*?)0*)?
	(?:[Zz]|[+-]${_23_}:${_59_})
	$`.valueOf();
var { exec: OFFSET_DATETIME_ZERO_exec } = newRegExp`
	^
	${YMD}
	[Tt ]
	${HMS}
	()
	[Zz]
	$`.valueOf();
var { test: IS_LOCAL_DATETIME } = newRegExp`
	^
	${YMD}
	[Tt ]
	${HMS}
	(?:\.\d+)?
	$`.valueOf();
var { test: IS_LOCAL_DATE } = newRegExp`
	^
	${YMD}
	$`.valueOf();
var { test: IS_LOCAL_TIME } = newRegExp`
	^
	${HMS}
	(?:\.\d+)?
	$`.valueOf();
var T = /[ t]/;
var DELIMITER_DOT = /[-T:.]/g;
var DOT_ZERO = /\.?0+$/;
var ZERO = /\.(\d*?)0+$/;
var zeroReplacer = (match, p1) => p1;
var Datetime = (() => {
  const Datetime2 = function() {
    return this;
  };
  const descriptors = Null$1(null);
  {
    const descriptor = Null$1(null);
    for (const key of ownKeys(NativeDate.prototype)) {
      key === "constructor" || key === "toJSON" || (descriptors[key] = descriptor);
    }
  }
  Datetime2.prototype = preventExtensions(create$1(NativeDate.prototype, descriptors));
  return freeze(Datetime2);
})();
var Value = (ISOString) => ISOString.replace(ZERO, zeroReplacer).replace(DELIMITER_DOT, "");
var d = /./gs;
var d2u = (d2) => "          "[d2];
var ValueOFFSET = (time, more) => time < 0 ? ("" + (time + 6216730554e4)).replace(d, d2u).padStart(14, " ") + more.replace(d, d2u) + time : more ? (time + ".").padStart(16, "0") + more : ("" + time).padStart(15, "0");
var validateLeap = (literal2) => {
  if (literal2.startsWith("02-29", 5)) {
    const year = +literal2.slice(0, 4);
    return year & 3 ? false : year % 100 ? true : year % 400 ? false : year % 3200 ? true : false;
  }
  return true;
};
var { test: VALIDATE_LEAP } = newRegExp.s`^.....(?:06.30|12.31).23:59:59`.valueOf();
var DATE$1 = defineProperties(new NativeDate(0), getOwnPropertyDescriptors(NativeDate.prototype));
var OffsetDateTime_ISOString = Symbol$1("OffsetDateTime_ISOString");
var OffsetDateTime_value = Symbol$1("OffsetDateTime_value");
var OffsetDateTime_use = (that, $ = 0) => {
  DATE$1.setTime(+that[OffsetDateTime_value] + $);
  return DATE$1;
};
var OffsetDateTime = fpc(class OffsetDateTime2 extends Datetime {
  [OffsetDateTime_ISOString];
  [OffsetDateTime_value];
  get [Symbol$1.toStringTag]() {
    return "OffsetDateTime";
  }
  valueOf() {
    return this[OffsetDateTime_value];
  }
  toISOString() {
    return this[OffsetDateTime_ISOString];
  }
  constructor(literal2) {
    validateLeap(literal2) || throws(SyntaxError$1(`Invalid Offset Date-Time ${literal2}` + where(" at ")));
    const with60 = literal2.startsWith("60", 17);
    let without60 = with60 ? literal2.slice(0, 17) + "59" + literal2.slice(19) : literal2;
    const { 1: more = "" } = (zeroDatetime ? OFFSET_DATETIME_ZERO_exec(without60) : OFFSET_DATETIME_exec(without60)) || throws(SyntaxError$1(`Invalid Offset Date-Time ${literal2}` + where(" at ")));
    const time = parse$2(without60 = without60.replace(T, "T").replace("z", "Z"));
    if (with60) {
      DATE$1.setTime(time);
      VALIDATE_LEAP(DATE$1.toISOString()) || throws(SyntaxError$1(`Invalid Offset Date-Time ${literal2}` + where(" at ")));
    }
    super();
    this[OffsetDateTime_ISOString] = without60;
    this[OffsetDateTime_value] = ValueOFFSET(time, more);
    return this;
  }
  getUTCFullYear() {
    return OffsetDateTime_use(this).getUTCFullYear();
  }
  ///get year () :FullYear { return OffsetDateTime_get(this, 0, 4); }
  ///set year (value :FullYear) { OffsetDateTime_set(this, 0, 4, value, true); }
  getUTCMonth() {
    return OffsetDateTime_use(this).getUTCMonth();
  }
  ///get month () { return OffsetDateTime_get(this, 5, 7); }
  ///set month (value) { OffsetDateTime_set(this, 5, 7, value, true); }
  getUTCDate() {
    return OffsetDateTime_use(this).getUTCDate();
  }
  ///get day () :Date { return OffsetDateTime_get(this, 8, 10); }
  ///set day (value :Date) { OffsetDateTime_set(this, 8, 10, value, true); }
  getUTCHours() {
    return OffsetDateTime_use(this).getUTCHours();
  }
  ///get hour () :Hours { return OffsetDateTime_get(this, 11, 13); }
  ///set hour (value :Hours) { OffsetDateTime_set(this, 11, 13, value, true); }
  getUTCMinutes() {
    return OffsetDateTime_use(this).getUTCMinutes();
  }
  ///get minute () :Minutes { return OffsetDateTime_get(this, 14, 16); }
  ///set minute (value :Minutes) { OffsetDateTime_set(this, 14, 16, value, true); }
  getUTCSeconds() {
    return OffsetDateTime_use(this).getUTCSeconds();
  }
  ///get second () :Seconds { return OffsetDateTime_get(this, 17, 19); }
  ///set second (value :Seconds) { OffsetDateTime_set(this, 17, 19, value, true); }
  getUTCMilliseconds() {
    return OffsetDateTime_use(this).getUTCMilliseconds();
  }
  ///
  ///get millisecond () :Milliseconds { return this[OffsetDateTime_value]%1000; }///
  /*set millisecond (value :Milliseconds) {
  	this[OffsetDateTime_ISOString] = this[OffsetDateTime_ISOString].slice(0, 19) + ( value ? ( '.' + ( '' + value ).padStart(3, '0') ).replace(DOT_ZERO, '') : '' ) + this[OffsetDateTime_ISOString].slice(this[OffsetDateTime_ISOString].search(OFFSET$));
  	OffsetDateTime_set(this, 0, 0, 0, false);
  }*/
  //
  ///get microsecond () :Milliseconds
  ///set microsecond (value :Milliseconds)
  ///get nanosecond () :Milliseconds
  ///set nanosecond (value :Milliseconds)
  getUTCDay() {
    return OffsetDateTime_use(this).getUTCDay();
  }
  ///get dayOfWeek () { return OffsetDateTime_use(this, this.getTimezoneOffset()*60000).getUTCDay() || 7; }
  getTimezoneOffset() {
    const z = Z_exec(this[OffsetDateTime_ISOString]);
    return z ? +z[1] * 60 + +(z[2] + z[3]) : 0;
  }
  ///get offset () { return this[OffsetDateTime_ISOString].endsWith('Z') ? 'Z' : this[OffsetDateTime_ISOString].slice(-6); }
  /*set offset (value) {
  	this[OffsetDateTime_ISOString] = this[OffsetDateTime_ISOString].slice(0, this[OffsetDateTime_ISOString].endsWith('Z') ? -1 : -6) + value;
  	OffsetDateTime_set(this, 0, 0, 0, true);
  }*/
  //
  getTime() {
    return floor(+this[OffsetDateTime_value]);
  }
  ///
  /*setTime (this :OffsetDateTime, value :Time) :void {
  	value = DATE.setTime(value);
  	const z = Z_exec(this[OffsetDateTime_ISOString]);
  	DATE.setTime(value + ( z ? +z[1]*60 + +( z[2] + z[3] ) : 0 )*60000);
  	this[OffsetDateTime_ISOString] = z ? DATE.toISOString().slice(0, -1) + z[0] : DATE.toISOString();
  	this[OffsetDateTime_value] = ValueOFFSET(value, '');
  	///return value;
  }*/
});
var LocalDateTime_ISOString = Symbol$1("LocalDateTime_ISOString");
var LocalDateTime_value = Symbol$1("LocalDateTime_value");
var LocalDateTime_get = (that, start, end) => +that[LocalDateTime_ISOString].slice(start, end);
var LocalDateTime_set = (that, start, end, value) => {
  const string = "" + value;
  const size = end - start;
  if (string.length > size) {
    throw RangeError$1();
  }
  that[LocalDateTime_value] = Value(
    that[LocalDateTime_ISOString] = that[LocalDateTime_ISOString].slice(0, start) + string.padStart(size, "0") + that[LocalDateTime_ISOString].slice(end)
  );
};
var LocalDateTime = fpc(class LocalDateTime2 extends Datetime {
  [LocalDateTime_ISOString];
  [LocalDateTime_value];
  get [Symbol$1.toStringTag]() {
    return "LocalDateTime";
  }
  valueOf() {
    return this[LocalDateTime_value];
  }
  toISOString() {
    return this[LocalDateTime_ISOString];
  }
  constructor(literal2) {
    IS_LOCAL_DATETIME(literal2) && validateLeap(literal2) || throws(SyntaxError$1(`Invalid Local Date-Time ${literal2}` + where(" at ")));
    super();
    this[LocalDateTime_value] = Value(
      this[LocalDateTime_ISOString] = literal2.replace(T, "T")
    );
    return this;
  }
  getFullYear() {
    return LocalDateTime_get(this, 0, 4);
  }
  setFullYear(value) {
    LocalDateTime_set(this, 0, 4, value);
  }
  getMonth() {
    return LocalDateTime_get(this, 5, 7) - 1;
  }
  setMonth(value) {
    LocalDateTime_set(this, 5, 7, value + 1);
  }
  getDate() {
    return LocalDateTime_get(this, 8, 10);
  }
  setDate(value) {
    LocalDateTime_set(this, 8, 10, value);
  }
  getHours() {
    return LocalDateTime_get(this, 11, 13);
  }
  setHours(value) {
    LocalDateTime_set(this, 11, 13, value);
  }
  getMinutes() {
    return LocalDateTime_get(this, 14, 16);
  }
  setMinutes(value) {
    LocalDateTime_set(this, 14, 16, value);
  }
  getSeconds() {
    return LocalDateTime_get(this, 17, 19);
  }
  setSeconds(value) {
    LocalDateTime_set(this, 17, 19, value);
  }
  getMilliseconds() {
    return +this[LocalDateTime_value].slice(14, 17).padEnd(3, "0");
  }
  ///
  setMilliseconds(value) {
    this[LocalDateTime_value] = Value(
      this[LocalDateTime_ISOString] = this[LocalDateTime_ISOString].slice(0, 19) + (value ? ("." + ("" + value).padStart(3, "0")).replace(DOT_ZERO, "") : "")
    );
  }
});
var LocalDate_ISOString = Symbol$1("LocalDate_ISOString");
var LocalDate_value = Symbol$1("LocalDate_value");
var LocalDate_get = (that, start, end) => +that[LocalDate_ISOString].slice(start, end);
var LocalDate_set = (that, start, end, value) => {
  const string = "" + value;
  const size = end - start;
  if (string.length > size) {
    throw RangeError$1();
  }
  that[LocalDate_value] = Value(
    that[LocalDate_ISOString] = that[LocalDate_ISOString].slice(0, start) + string.padStart(size, "0") + that[LocalDate_ISOString].slice(end)
  );
};
var LocalDate = fpc(class LocalDate2 extends Datetime {
  [LocalDate_ISOString];
  [LocalDate_value];
  get [Symbol$1.toStringTag]() {
    return "LocalDate";
  }
  valueOf() {
    return this[LocalDate_value];
  }
  toISOString() {
    return this[LocalDate_ISOString];
  }
  constructor(literal2) {
    IS_LOCAL_DATE(literal2) && validateLeap(literal2) || throws(SyntaxError$1(`Invalid Local Date ${literal2}` + where(" at ")));
    super();
    this[LocalDate_value] = Value(
      this[LocalDate_ISOString] = literal2
    );
    return this;
  }
  getFullYear() {
    return LocalDate_get(this, 0, 4);
  }
  setFullYear(value) {
    LocalDate_set(this, 0, 4, value);
  }
  getMonth() {
    return LocalDate_get(this, 5, 7) - 1;
  }
  setMonth(value) {
    LocalDate_set(this, 5, 7, value + 1);
  }
  getDate() {
    return LocalDate_get(this, 8, 10);
  }
  setDate(value) {
    LocalDate_set(this, 8, 10, value);
  }
});
var LocalTime_ISOString = Symbol$1("LocalTime_ISOString");
var LocalTime_value = Symbol$1("LocalTime_value");
var LocalTime_get = (that, start, end) => +that[LocalTime_ISOString].slice(start, end);
var LocalTime_set = (that, start, end, value) => {
  const string = "" + value;
  const size = end - start;
  if (string.length > size) {
    throw RangeError$1();
  }
  that[LocalTime_value] = Value(
    that[LocalTime_ISOString] = that[LocalTime_ISOString].slice(0, start) + string.padStart(2, "0") + that[LocalTime_ISOString].slice(end)
  );
};
var LocalTime = fpc(class LocalTime2 extends Datetime {
  [LocalTime_ISOString];
  [LocalTime_value];
  get [Symbol$1.toStringTag]() {
    return "LocalTime";
  }
  valueOf() {
    return this[LocalTime_value];
  }
  toISOString() {
    return this[LocalTime_ISOString];
  }
  constructor(literal2) {
    IS_LOCAL_TIME(literal2) || throws(SyntaxError$1(`Invalid Local Time ${literal2}` + where(" at ")));
    super();
    this[LocalTime_value] = Value(
      this[LocalTime_ISOString] = literal2
    );
    return this;
  }
  getHours() {
    return LocalTime_get(this, 0, 2);
  }
  setHours(value) {
    LocalTime_set(this, 0, 2, value);
  }
  getMinutes() {
    return LocalTime_get(this, 3, 5);
  }
  setMinutes(value) {
    LocalTime_set(this, 3, 5, value);
  }
  getSeconds() {
    return LocalTime_get(this, 6, 8);
  }
  setSeconds(value) {
    LocalTime_set(this, 6, 8, value);
  }
  getMilliseconds() {
    return +this[LocalTime_value].slice(6, 9).padEnd(3, "0");
  }
  ///
  setMilliseconds(value) {
    this[LocalTime_value] = Value(
      this[LocalTime_ISOString] = this[LocalTime_ISOString].slice(0, 8) + (value ? ("." + ("" + value).padStart(3, "0")).replace(DOT_ZERO, "") : "")
    );
  }
});
var parseInt$1 = parseInt;
var fromCodePoint = String.fromCodePoint;
var ESCAPED_IN_SINGLE_LINE = /[^\\]+|\\(?:[\\"btnfr/]|u.{4}|U.{8})/gs;
var ESCAPED_IN_MULTI_LINE = /[^\n\\]+|\n|\\(?:[\t ]*\n[\t\n ]*|[\\"btnfr/]|u.{4}|U.{8})/gs;
var BasicString = (literal2) => {
  if (!literal2) {
    return "";
  }
  const parts = literal2.match(ESCAPED_IN_SINGLE_LINE);
  const { length } = parts;
  let index = 0;
  do {
    const part = parts[index];
    if (part[0] === "\\") {
      switch (part[1]) {
        case "\\":
          parts[index] = "\\";
          break;
        case '"':
          parts[index] = '"';
          break;
        case "b":
          parts[index] = "\b";
          break;
        case "t":
          parts[index] = "	";
          break;
        case "n":
          parts[index] = "\n";
          break;
        case "f":
          parts[index] = "\f";
          break;
        case "r":
          parts[index] = "\r";
          break;
        case "u":
          const charCode = parseInt$1(part.slice(2), 16);
          mustScalar && 55295 < charCode && charCode < 57344 && throws(RangeError$1(`Invalid Unicode Scalar ${part}` + where(" at ")));
          parts[index] = fromCharCode(charCode);
          break;
        case "U":
          const codePoint = parseInt$1(part.slice(2), 16);
          (mustScalar && 55295 < codePoint && codePoint < 57344 || 1114111 < codePoint) && throws(RangeError$1(`Invalid Unicode Scalar ${part}` + where(" at ")));
          parts[index] = fromCodePoint(codePoint);
          break;
        case "/":
          parts[index] = "/";
          break;
      }
    }
  } while (++index !== length);
  return parts.join("");
};
var MultilineBasicString = (literal2, useWhatToJoinMultilineString2, n) => {
  if (!literal2) {
    return "";
  }
  const parts = literal2.match(ESCAPED_IN_MULTI_LINE);
  const { length } = parts;
  let index = 0;
  do {
    const part = parts[index];
    if (part === "\n") {
      ++n;
      parts[index] = useWhatToJoinMultilineString2;
    } else if (part[0] === "\\") {
      switch (part[1]) {
        case "\n":
        case " ":
        case "	":
          for (let i = 0; i = part.indexOf("\n", i) + 1; ) {
            ++n;
          }
          parts[index] = "";
          break;
        case "\\":
          parts[index] = "\\";
          break;
        case '"':
          parts[index] = '"';
          break;
        case "b":
          parts[index] = "\b";
          break;
        case "t":
          parts[index] = "	";
          break;
        case "n":
          parts[index] = "\n";
          break;
        case "f":
          parts[index] = "\f";
          break;
        case "r":
          parts[index] = "\r";
          break;
        case "u":
          const charCode = parseInt$1(part.slice(2), 16);
          mustScalar && 55295 < charCode && charCode < 57344 && throws(RangeError$1(`Invalid Unicode Scalar ${part}` + where(" at ", lineIndex + n)));
          parts[index] = fromCharCode(charCode);
          break;
        case "U":
          const codePoint = parseInt$1(part.slice(2), 16);
          (mustScalar && 55295 < codePoint && codePoint < 57344 || 1114111 < codePoint) && throws(RangeError$1(`Invalid Unicode Scalar ${part}` + where(" at ", lineIndex + n)));
          parts[index] = fromCodePoint(codePoint);
          break;
        case "/":
          parts[index] = "/";
          break;
      }
    }
  } while (++index !== length);
  return parts.join("");
};
var INTEGER_D = /[-+]?(?:0|[1-9][_\d]*)/;
var { test: BAD_D } = newRegExp`_(?!\d)`.valueOf();
var { test: IS_D_INTEGER } = newRegExp`^${INTEGER_D}$`.valueOf();
var { test: IS_XOB_INTEGER } = theRegExp(/^0(?:x[\dA-Fa-f][_\dA-Fa-f]*|o[0-7][_0-7]*|b[01][_01]*)$/);
var { test: BAD_XOB } = newRegExp`_(?![\dA-Fa-f])`.valueOf();
var UNDERSCORES$1 = /_/g;
var UNDERSCORES_SIGN = /_|^[-+]/g;
var IS_INTEGER = (literal2) => (IS_D_INTEGER(literal2) || /*options.xob && */
IS_XOB_INTEGER(literal2)) && !BAD_XOB(literal2);
var MIN = BigInt$1 && -BigInt$1("0x8000000000000000");
var MAX = BigInt$1 && BigInt$1("0x7FFFFFFFFFFFFFFF");
var BigIntInteger = (literal2) => {
  IS_INTEGER(literal2) || throws(SyntaxError$1(`Invalid Integer ${literal2}` + where(" at ")));
  const bigInt = literal2[0] === "-" ? -BigInt$1(literal2.replace(UNDERSCORES_SIGN, "")) : BigInt$1(literal2.replace(UNDERSCORES_SIGN, ""));
  allowLonger || MIN <= bigInt && bigInt <= MAX || throws(RangeError$1(`Integer expect 64 bit range (-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807), not includes ${literal2}` + where(" meet at ")));
  return bigInt;
};
var NumberInteger = (literal2) => {
  IS_INTEGER(literal2) || throws(SyntaxError$1(`Invalid Integer ${literal2}` + where(" at ")));
  const number = parseInt$1(literal2.replace(UNDERSCORES$1, ""));
  isSafeInteger(number) || throws(RangeError$1(`Integer did not use BitInt must fit Number.isSafeInteger, not includes ${literal2}` + where(" meet at ")));
  return number;
};
var Integer = (literal2) => {
  if (usingBigInt === true) {
    return BigIntInteger(literal2);
  }
  if (usingBigInt === false) {
    return NumberInteger(literal2);
  }
  IS_INTEGER(literal2) || throws(SyntaxError$1(`Invalid Integer ${literal2}` + where(" at ")));
  const number = parseInt$1(literal2.replace(UNDERSCORES$1, ""));
  if (IntegerMinNumber <= number && number <= IntegerMaxNumber) {
    return number;
  }
  const bigInt = literal2[0] === "-" ? -BigInt$1(literal2.replace(UNDERSCORES_SIGN, "")) : BigInt$1(literal2.replace(UNDERSCORES_SIGN, ""));
  allowLonger || MIN <= bigInt && bigInt <= MAX || throws(RangeError$1(`Integer expect 64 bit range (-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807), not includes ${literal2}` + where(" meet at ")));
  return bigInt;
};
var isFinite$1 = isFinite;
var NaN$1 = 0 / 0;
var _NaN = -NaN$1;
var _Infinity$1 = -Infinity;
var { test: IS_FLOAT } = newRegExp`
	^
	${INTEGER_D}
	(?:
		\.\d[_\d]*
		(?:[eE][-+]?\d[_\d]*)?
	|
		[eE][-+]?\d[_\d]*
	)
	$`.valueOf();
var UNDERSCORES = /_/g;
var { test: IS_ZERO } = theRegExp(/^[-+]?0(?:\.0+)?(?:[eE][-+]?0+)?$/);
var { exec: NORMALIZED } = theRegExp(/^[-0]?(\d*)(?:\.(\d+))?(?:e\+?(-?\d+))?$/);
var { exec: ORIGINAL } = theRegExp(/^[-+]?0?(\d*)(?:\.(\d*?)0*)?(?:[eE]\+?(-?\d+))?$/);
var Float = (literal2) => {
  if (!IS_FLOAT(literal2) || BAD_D(literal2)) {
    if (sFloat) {
      if (literal2 === "inf" || literal2 === "+inf") {
        return Infinity;
      }
      if (literal2 === "-inf") {
        return _Infinity$1;
      }
      if (literal2 === "nan" || literal2 === "+nan") {
        return NaN$1;
      }
      if (literal2 === "-nan") {
        return _NaN;
      }
    } else if (!sError) {
      if (literal2 === "inf" || literal2 === "+inf") {
        return Infinity;
      }
      if (literal2 === "-inf") {
        return _Infinity$1;
      }
    }
    throw throws(SyntaxError$1(`Invalid Float ${literal2}` + where(" at ")));
  }
  const withoutUnderscores = literal2.replace(UNDERSCORES, "");
  const number = +withoutUnderscores;
  if (sError) {
    isFinite$1(number) || throws(RangeError$1(`Float ${literal2} has been as big as inf` + where(" at ")));
    number || IS_ZERO(withoutUnderscores) || throws(RangeError$1(`Float ${literal2} has been as little as ${literal2[0] === "-" ? "-" : ""}0` + where(" at ")));
    const { 1: normalized_integer, 2: normalized_fractional = "", 3: normalized_exponent = "" } = NORMALIZED(number);
    const { 1: original_integer, 2: original_fractional = "", 3: original_exponent = "" } = ORIGINAL(withoutUnderscores);
    original_integer + original_fractional === normalized_integer + normalized_fractional && original_exponent - original_fractional.length === normalized_exponent - normalized_fractional.length || throws(RangeError$1(`Float ${literal2} has lost its exact and been ${number}` + where(" at ")));
  }
  return number;
};
var prepareTable = (table, keys2) => {
  const { length } = keys2;
  let index = 0;
  while (index < length) {
    const key = keys2[index++];
    if (key in table) {
      table = table[key];
      if (isTable(table)) {
        isInline(table) && throws(Error$1(`Trying to define Table under Inline Table` + where(" at ")));
      } else if (isArray(table)) {
        isStatic(table) && throws(Error$1(`Trying to append value to Static Array` + where(" at ")));
        table = table[table.length - 1];
      } else {
        throw throws(Error$1(`Trying to define Table under non-Table value` + where(" at ")));
      }
    } else {
      table = table[key] = new Table3(IMPLICITLY);
      while (index < length) {
        table = table[keys2[index++]] = new Table3(IMPLICITLY);
      }
      return table;
    }
  }
  return table;
};
var appendTable = (table, finalKey, asArrayItem, tag) => {
  let lastTable;
  if (asArrayItem) {
    let arrayOfTables;
    if (finalKey in table) {
      isArray(arrayOfTables = table[finalKey]) && !isStatic(arrayOfTables) || throws(Error$1(`Trying to push Table to non-ArrayOfTables value` + where(" at ")));
    } else {
      arrayOfTables = table[finalKey] = newArray(OF_TABLES);
    }
    tag && collect(tag, arrayOfTables, table, finalKey);
    arrayOfTables[arrayOfTables.length] = lastTable = new Table3(DIRECTLY);
  } else {
    if (finalKey in table) {
      lastTable = table[finalKey];
      fromPair(lastTable) && throws(Error$1(`A table defined implicitly via key/value pair can not be accessed to via []` + where(", which at ")));
      directlyIfNot(lastTable) || throws(Error$1(`Duplicate Table definition` + where(" at ")));
    } else {
      table[finalKey] = lastTable = new Table3(DIRECTLY);
    }
    tag && collect(tag, null, table, finalKey);
  }
  return lastTable;
};
var prepareInlineTable = (table, keys2) => {
  const { length } = keys2;
  let index = 0;
  while (index < length) {
    const key = keys2[index++];
    if (key in table) {
      table = table[key];
      isTable(table) || throws(Error$1(`Trying to assign property through non-Table value` + where(" at ")));
      isInline(table) && throws(Error$1(`Trying to assign property through static Inline Table` + where(" at ")));
      fromPair(table) || throws(Error$1(`A table defined implicitly via [] can not be accessed to via key/value pair` + where(", which at ")));
    } else {
      table = table[key] = new Table3(IMPLICITLY, PAIR);
      while (index < length) {
        table = table[keys2[index++]] = new Table3(IMPLICITLY, PAIR);
      }
      return table;
    }
  }
  return table;
};
var checkLiteralString = (literal2) => {
  __CONTROL_CHARACTER_EXCLUDE_test(literal2) && throws(SyntaxError$1(`Control characters other than Tab are not permitted in a Literal String` + where(", which was found at ")));
  return literal2;
};
var assignLiteralString = ((table, finalKey, literal2) => {
  if (!literal2.startsWith(`'''`)) {
    const $2 = LITERAL_STRING_exec(literal2) || throws(SyntaxError$1(`Bad literal string` + where(" at ")));
    const value = checkLiteralString($2[1]);
    table[finalKey] = preserveLiteral ? LiteralObject(literal2.slice(0, value.length + 2), value) : value;
    return $2[2];
  }
  const $ = __MULTI_LINE_LITERAL_STRING_exec(literal2.slice(3));
  if ($) {
    const value = checkLiteralString($[1]) + $[2];
    table[finalKey] = preserveLiteral ? LiteralObject(literal2.slice(0, value.length + 6), value) : value;
    return $[3];
  }
  const start = new mark("Multi-line Literal String", literal2.length);
  const leadingNewline = !(literal2 = literal2.slice(3));
  if (leadingNewline) {
    literal2 = start.must();
    const $2 = __MULTI_LINE_LITERAL_STRING_exec(literal2);
    if ($2) {
      const value = checkLiteralString($2[1]) + $2[2];
      table[finalKey] = preserveLiteral ? LiteralObject([`'''`, literal2.slice(0, value.length + 3)], value) : value;
      return $2[3];
    }
  }
  useWhatToJoinMultilineString === null && start.nowrap(ARGS_MODE);
  for (const lines = [checkLiteralString(literal2)]; ; ) {
    const line = start.must();
    const $2 = __MULTI_LINE_LITERAL_STRING_exec(line);
    if ($2) {
      lines[lines.length] = checkLiteralString($2[1]) + $2[2];
      const value = lines.join(useWhatToJoinMultilineString);
      if (preserveLiteral) {
        lines[lines.length - 1] += `'''`;
        leadingNewline ? lines.unshift(`'''`) : lines[0] = `'''${literal2}`;
        table[finalKey] = LiteralObject(lines, value);
      } else {
        table[finalKey] = value;
      }
      return $2[3];
    }
    lines[lines.length] = checkLiteralString(line);
  }
});
var assignBasicString = ((table, finalKey, literal2) => {
  if (!literal2.startsWith('"""')) {
    const index = BASIC_STRING_exec_1_endIndex(literal2);
    const value = BasicString(literal2.slice(1, index));
    table[finalKey] = preserveLiteral ? LiteralObject(literal2.slice(0, index + 1), value) : value;
    return literal2.slice(index + 1).replace(PRE_WHITESPACE, "");
  }
  let length = 3 + MULTI_LINE_BASIC_STRING_exec_0_length(literal2.slice(3));
  if (literal2.length !== length) {
    const $ = literal2.slice(3, length);
    ESCAPED_EXCLUDE_CONTROL_CHARACTER_test($) || throws(SyntaxError$1(`Bad multi-line basic string` + where(" at ")));
    const value = BasicString($) + (literal2.startsWith('"', length += 3) ? literal2.startsWith('"', ++length) ? (++length, '""') : '"' : "");
    table[finalKey] = preserveLiteral ? LiteralObject(literal2.slice(0, length), value) : value;
    return literal2.slice(length).replace(PRE_WHITESPACE, "");
  }
  const start = new mark("Multi-line Basic String", length);
  const skipped = (literal2 = literal2.slice(3)) ? 0 : 1;
  if (skipped) {
    literal2 = start.must();
    let length2 = MULTI_LINE_BASIC_STRING_exec_0_length(literal2);
    if (literal2.length !== length2) {
      const $ = literal2.slice(0, length2);
      ESCAPED_EXCLUDE_CONTROL_CHARACTER_test($) || throws(SyntaxError$1(`Bad multi-line basic string` + where(" at ")));
      const value = MultilineBasicString($, useWhatToJoinMultilineString, skipped) + (literal2.startsWith('"', length2 += 3) ? literal2.startsWith('"', ++length2) ? (++length2, '""') : '"' : "");
      table[finalKey] = preserveLiteral ? LiteralObject(['"""', literal2.slice(0, length2)], value) : value;
      return literal2.slice(length2).replace(PRE_WHITESPACE, "");
    }
  }
  useWhatToJoinMultilineString === null && start.nowrap(ARGS_MODE);
  ESCAPED_EXCLUDE_CONTROL_CHARACTER_test(literal2 + "\n") || throws(SyntaxError$1(`Bad multi-line basic string` + where(" at ")));
  for (const lines = [literal2]; ; ) {
    const line = start.must();
    let length2 = MULTI_LINE_BASIC_STRING_exec_0_length(line);
    if (line.length !== length2) {
      const $ = line.slice(0, length2);
      ESCAPED_EXCLUDE_CONTROL_CHARACTER_test($) || throws(SyntaxError$1(`Bad multi-line basic string` + where(" at ")));
      const value = MultilineBasicString(lines.join("\n") + "\n" + $, useWhatToJoinMultilineString, skipped) + (line.startsWith('"', length2 += 3) ? line.startsWith('"', ++length2) ? (++length2, '""') : '"' : "");
      if (preserveLiteral) {
        skipped ? lines.unshift('"""') : lines[0] = `"""${literal2}`;
        lines[lines.length] = `${$}"""`;
        table[finalKey] = LiteralObject(lines, value);
      } else {
        table[finalKey] = value;
      }
      return line.slice(length2).replace(PRE_WHITESPACE, "");
    }
    ESCAPED_EXCLUDE_CONTROL_CHARACTER_test(line + "\n") || throws(SyntaxError$1(`Bad multi-line basic string` + where(" at ")));
    lines[lines.length] = line;
  }
});
var KEYS = Null$1(null);
var commentFor = (key) => KEYS[key] || (KEYS[key] = Symbol$1(key));
var commentForThis = Symbol$1("this");
var { test: includesNewline } = theRegExp(/\r?\n/g);
var getCOMMENT = (table, keyComment) => {
  if (keyComment in table) {
    const comment = table[keyComment];
    if (typeof comment !== "string") {
      throw TypeError$1(`the value of comment must be a string, while "${comment === null ? "null" : typeof comment}" type is found`);
    }
    if (includesNewline(comment)) {
      throw SyntaxError$1(`the value of comment must be a string and can not include newline`);
    }
    return ` #${comment}`;
  }
  return "";
};
var getComment = (table, key) => key in KEYS ? getCOMMENT(table, KEYS[key]) : "";
var { test: IS_OFFSET$ } = theRegExp(OFFSET$);
var { test: IS_EMPTY } = theRegExp(/^\[[\t ]*]/);
var parseKeys = (rest2) => {
  let lineRest = rest2;
  const leadingKeys = [];
  let lastIndex = -1;
  for (; ; ) {
    lineRest || throws(SyntaxError$1(`Empty bare key` + where(" at ")));
    if (lineRest[0] === '"') {
      const index = BASIC_STRING_exec_1_endIndex(lineRest);
      KEYS$1.test(leadingKeys[++lastIndex] = BasicString(lineRest.slice(1, index))) || throws(Error$1(`Key not allowed` + where(" at ")));
      lineRest = lineRest.slice(index + 1);
    } else {
      const isQuoted = lineRest[0] === "'";
      const key = ((isQuoted ? __LITERAL_KEY_exec : __BARE_KEY_exec)(lineRest) || throws(SyntaxError$1(`Bad ${isQuoted ? "literal string" : "bare"} key` + where(" at "))))[0];
      lineRest = lineRest.slice(key.length);
      KEYS$1.test(leadingKeys[++lastIndex] = isQuoted ? key.slice(1, -1) : key) || throws(Error$1(`Key not allowed` + where(" at ")));
    }
    if (IS_DOT_KEY(lineRest)) {
      lineRest = lineRest.replace(DOT_KEY, "");
    } else {
      break;
    }
  }
  if (disableDigit) {
    const keys2 = rest2.slice(0, -lineRest.length);
    (isAmazing(keys2) || enableNull && keys2 === "null") && throws(SyntaxError$1(`Bad bare key disabled by xOptions.string` + where(" at ")));
  }
  if (disallowEmptyKey) {
    let index = lastIndex;
    do {
      leadingKeys[index] || throws(SyntaxError$1(`Empty key is not allowed before TOML v0.5` + where(", which at ")));
    } while (index--);
  }
  const finalKey = leadingKeys[lastIndex];
  leadingKeys.length = lastIndex;
  return { leadingKeys, finalKey, lineRest };
};
var push = (lastArray, lineRest) => {
  if (lineRest[0] === "<") {
    const { 1: tag } = { 2: lineRest } = _VALUE_PAIR_exec(lineRest) || throws(SyntaxError$1(`Bad tag ` + where(" at ")));
    collect(tag, lastArray, null);
    switch (lineRest && lineRest[0]) {
      case ",":
      case "]":
      case "":
      case "#":
        lastArray[lastArray.length] = undefined$1;
        return lineRest;
    }
  }
  switch (lineRest[0]) {
    case "'":
      return assignLiteralString(asStrings(lastArray), lastArray.length, lineRest);
    case '"':
      return assignBasicString(asStrings(lastArray), lastArray.length, lineRest);
    case "{":
      inlineTable || throws(SyntaxError$1(`Inline Table is not allowed before TOML v0.4` + where(", which at ")));
      return equalInlineTable(asTables(lastArray), lastArray.length, lineRest);
    case "[":
      return equalStaticArray(asArrays(lastArray), lastArray.length, lineRest);
  }
  const { 1: literal2 } = { 2: lineRest } = VALUE_REST_exec(lineRest) || throws(SyntaxError$1(`Bad atom value` + where(" at ")));
  if (literal2 === "true") {
    asBooleans(lastArray)[lastArray.length] = true;
  } else if (literal2 === "false") {
    asBooleans(lastArray)[lastArray.length] = false;
  } else if (enableNull && literal2 === "null") {
    asNulls(lastArray)[lastArray.length] = null;
  } else if (literal2.includes(":")) {
    if (literal2.includes("-")) {
      if (IS_OFFSET$(literal2)) {
        asOffsetDateTimes(lastArray)[lastArray.length] = new OffsetDateTime(literal2);
      } else {
        moreDatetime || throws(SyntaxError$1(`Local Date-Time is not allowed before TOML v0.5` + where(", which at ")));
        asLocalDateTimes(lastArray)[lastArray.length] = new LocalDateTime(literal2);
      }
    } else {
      moreDatetime || throws(SyntaxError$1(`Local Time is not allowed before TOML v0.5` + where(", which at ")));
      asLocalTimes(lastArray)[lastArray.length] = new LocalTime(literal2);
    }
  } else if (literal2.indexOf("-") !== literal2.lastIndexOf("-") && literal2[0] !== "-") {
    moreDatetime || throws(SyntaxError$1(`Local Date is not allowed before TOML v0.5` + where(", which at ")));
    asLocalDates(lastArray)[lastArray.length] = new LocalDate(literal2);
  } else {
    literal2.includes(".") || literal2.includes("n") || (literal2.includes("e") || literal2.includes("E")) && !literal2.startsWith("0x") ? asFloats(lastArray)[lastArray.length] = preserveLiteral ? LiteralObject(literal2, Float(literal2)) : Float(literal2) : asIntegers(lastArray)[lastArray.length] = preserveLiteral ? LiteralObject(literal2, Integer(literal2)) : Integer(literal2);
  }
  return lineRest;
};
var equalStaticArray = function* (table, finalKey, lineRest) {
  const staticArray = table[finalKey] = newArray(STATICALLY);
  if (IS_EMPTY(lineRest)) {
    beInline(staticArray, lineRest[1] === "]" ? 0 : 3);
    return lineRest.slice(lineRest.indexOf("]")).replace(SYM_WHITESPACE, "");
  }
  const start = new mark("Static Array", lineRest.length);
  let inline2 = lineRest.startsWith("[ ") || lineRest.startsWith("[	") ? 3 : 0;
  lineRest = lineRest.replace(SYM_WHITESPACE, "");
  while (!lineRest || lineRest[0] === "#") {
    inline2 = null;
    lineRest = start.must().replace(PRE_WHITESPACE, "");
  }
  if (lineRest[0] === "]") {
    inline2 === null || beInline(staticArray, inline2);
    return lineRest.replace(SYM_WHITESPACE, "");
  }
  for (; ; ) {
    const rest2 = push(staticArray, lineRest);
    lineRest = typeof rest2 === "string" ? rest2 : yield rest2;
    while (!lineRest || lineRest[0] === "#") {
      inline2 = null;
      lineRest = start.must().replace(PRE_WHITESPACE, "");
    }
    if (lineRest[0] === ",") {
      lineRest = lineRest.replace(SYM_WHITESPACE, "");
      while (!lineRest || lineRest[0] === "#") {
        inline2 = null;
        lineRest = start.must().replace(PRE_WHITESPACE, "");
      }
      if (lineRest[0] === "]") {
        break;
      }
    } else {
      if (lineRest[0] === "]") {
        break;
      }
      throw throws(SyntaxError$1(`Unexpect character in static array item value` + where(", which is found at ")));
    }
  }
  inline2 === null || beInline(staticArray, inline2);
  return lineRest.replace(SYM_WHITESPACE, "");
};
var equalInlineTable = function* (table, finalKey, lineRest) {
  const inlineTable2 = table[finalKey] = new Table3(DIRECTLY, INLINE);
  if (allowInlineTableMultilineAndTrailingCommaEvenNoComma) {
    const start = new mark("Inline Table", lineRest.length);
    lineRest = lineRest.replace(SYM_WHITESPACE, "");
    let inline2 = true;
    for (; ; ) {
      while (!lineRest || lineRest[0] === "#") {
        inline2 = false;
        lineRest = start.must().replace(PRE_WHITESPACE, "");
      }
      if (lineRest[0] === "}") {
        break;
      }
      const forComment = ForComment(inlineTable2, lineRest);
      const rest2 = assign(forComment);
      lineRest = typeof rest2 === "string" ? rest2 : yield rest2;
      if (lineRest) {
        if (lineRest[0] === "#") {
          if (preserveComment) {
            forComment.table[commentFor(forComment.finalKey)] = lineRest.slice(1);
          }
          inline2 = false;
          do {
            lineRest = start.must().replace(PRE_WHITESPACE, "");
          } while (!lineRest || lineRest[0] === "#");
        }
      } else {
        inline2 = false;
        do {
          lineRest = start.must().replace(PRE_WHITESPACE, "");
        } while (!lineRest || lineRest[0] === "#");
      }
      if (lineRest[0] === ",") {
        lineRest = lineRest.replace(SYM_WHITESPACE, "");
      }
    }
    inline2 || beInline(inlineTable2, false);
  } else {
    lineRest = lineRest.replace(SYM_WHITESPACE, "") || throws(SyntaxError$1(`Inline Table is intended to appear on a single line` + where(", which broken at ")));
    if (lineRest[0] !== "}") {
      for (; ; ) {
        lineRest[0] === "#" && throws(SyntaxError$1(`Inline Table is intended to appear on a single line` + where(", which broken at ")));
        const rest2 = assign(ForComment(inlineTable2, lineRest));
        lineRest = (typeof rest2 === "string" ? rest2 : yield rest2) || throws(SyntaxError$1(`Inline Table is intended to appear on a single line` + where(", which broken at ")));
        if (lineRest[0] === "}") {
          break;
        }
        if (lineRest[0] === ",") {
          lineRest = lineRest.replace(SYM_WHITESPACE, "") || throws(SyntaxError$1(`Inline Table is intended to appear on a single line` + where(", which broken at ")));
          lineRest[0] === "}" && throws(SyntaxError$1(`The last property of an Inline Table can not have a trailing comma` + where(", which was found at ")));
        }
      }
    }
  }
  return lineRest.replace(SYM_WHITESPACE, "");
};
var ForComment = (lastInlineTable, lineRest) => {
  const { leadingKeys, finalKey, tag } = { lineRest } = KEY_VALUE_PAIR_exec_groups(parseKeys(lineRest));
  return { table: prepareInlineTable(lastInlineTable, leadingKeys), finalKey, tag, lineRest };
};
var assign = ({ finalKey, tag, lineRest, table }) => {
  finalKey in table && throws(Error$1(`Duplicate property definition` + where(" at ")));
  if (tag) {
    collect(tag, null, table, finalKey);
    switch (lineRest && lineRest[0]) {
      case ",":
      case "}":
      case "":
      case "#":
        table[finalKey] = undefined$1;
        return lineRest;
    }
  }
  switch (lineRest && lineRest[0]) {
    case "'":
      return assignLiteralString(table, finalKey, lineRest);
    case '"':
      return assignBasicString(table, finalKey, lineRest);
    case "{":
      inlineTable || throws(SyntaxError$1(`Inline Table is not allowed before TOML v0.4` + where(", which at ")));
      return equalInlineTable(table, finalKey, lineRest);
    case "[":
      return equalStaticArray(table, finalKey, lineRest);
  }
  const { 1: literal2 } = { 2: lineRest } = VALUE_REST_exec(lineRest) || throws(SyntaxError$1(`Bad atom value` + where(" at ")));
  if (literal2 === "true") {
    table[finalKey] = true;
  } else if (literal2 === "false") {
    table[finalKey] = false;
  } else if (enableNull && literal2 === "null") {
    table[finalKey] = null;
  } else if (literal2.includes(":")) {
    if (literal2.includes("-")) {
      if (IS_OFFSET$(literal2)) {
        table[finalKey] = new OffsetDateTime(literal2);
      } else {
        moreDatetime || throws(SyntaxError$1(`Local Date-Time is not allowed before TOML v0.5` + where(", which at ")));
        table[finalKey] = new LocalDateTime(literal2);
      }
    } else {
      moreDatetime || throws(SyntaxError$1(`Local Time is not allowed before TOML v0.5` + where(", which at ")));
      table[finalKey] = new LocalTime(literal2);
    }
  } else if (literal2.indexOf("-") !== literal2.lastIndexOf("-") && literal2[0] !== "-") {
    moreDatetime || throws(SyntaxError$1(`Local Date is not allowed before TOML v0.5` + where(", which at ")));
    table[finalKey] = new LocalDate(literal2);
  } else {
    table[finalKey] = literal2.includes(".") || literal2.includes("n") || (literal2.includes("e") || literal2.includes("E")) && !literal2.startsWith("0x") ? preserveLiteral ? LiteralObject(literal2, Float(literal2)) : Float(literal2) : preserveLiteral ? LiteralObject(literal2, Integer(literal2)) : Integer(literal2);
  }
  return lineRest;
};
var Root = () => {
  const rootTable = new Table3();
  let lastSectionTable = rootTable;
  while (rest()) {
    const line = next().replace(PRE_WHITESPACE, "");
    if (line) {
      if (line[0] === "[") {
        const { leadingKeys, finalKey, asArrayItem, tag, lineRest } = TABLE_DEFINITION_exec_groups(line, parseKeys);
        const table = prepareTable(rootTable, leadingKeys);
        if (lineRest) {
          lineRest[0] === "#" || throws(SyntaxError$1(`Unexpect charachtor after table header` + where(" at ")));
        }
        lastSectionTable = appendTable(table, finalKey, asArrayItem, tag);
        preserveComment && lineRest && (lastSectionTable[commentForThis] = asArrayItem ? lineRest.slice(1) : table[commentFor(finalKey)] = lineRest.slice(1));
      } else if (line[0] === "#") {
        __CONTROL_CHARACTER_EXCLUDE_test(line) && throws(SyntaxError$1(`Control characters other than Tab are not permitted in comments` + where(", which was found at ")));
      } else {
        const forComment = ForComment(lastSectionTable, line);
        let rest2 = assign(forComment);
        typeof rest2 === "string" || (rest2 = x(rest2));
        if (rest2) {
          rest2[0] === "#" || throws(SyntaxError$1(`Unexpect charachtor after key/value pair` + where(" at ")));
          if (preserveComment) {
            forComment.table[commentFor(forComment.finalKey)] = rest2.slice(1);
          }
        }
      }
    }
  }
  return rootTable;
};
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
var DATE = Date.prototype;
var valueOf$2 = String.prototype.valueOf;
var isString = (
  /* j-globals: class.isString (internal) */
  (function() {
    if (apply.bind) {
      var valueOf_apply = apply.bind(valueOf$2);
      return function isString2(value) {
        try {
          valueOf_apply(value);
        } catch (error) {
          return false;
        }
        return true;
      };
    }
    return function isString2(value) {
      try {
        valueOf$2.apply(value);
      } catch (error) {
        return false;
      }
      return true;
    };
  })()
);
var valueOf$1 = Number.prototype.valueOf;
var isNumber = (
  /* j-globals: class.isNumber (internal) */
  (function() {
    if (apply.bind) {
      var valueOf_apply = apply.bind(valueOf$1);
      return function isNumber2(value) {
        try {
          valueOf_apply(value);
        } catch (error) {
          return false;
        }
        return true;
      };
    }
    return function isNumber2(value) {
      try {
        valueOf$1.apply(value);
      } catch (error) {
        return false;
      }
      return true;
    };
  })()
);
var isBigInt = (
  /* j-globals: class.isBigInt (internal) */
  (function() {
    if (typeof BigInt === "function") {
      var valueOf_apply = apply.bind(BigInt.prototype.valueOf);
      return function isBigInt2(value) {
        try {
          valueOf_apply(value);
        } catch (error) {
          return false;
        }
        return true;
      };
    }
    return function isBigInt2() {
      return false;
    };
  })()
);
var valueOf = BigInt.prototype.valueOf;
var isBoolean = (
  /* j-globals: class.isBoolean (internal) */
  (function() {
    if (apply.bind) {
      var valueOf_apply = apply.bind(valueOf);
      return function isBoolean2(value) {
        try {
          valueOf_apply(value);
        } catch (error) {
          return false;
        }
        return true;
      };
    }
    return function isBoolean2(value) {
      try {
        valueOf.apply(value);
      } catch (error) {
        return false;
      }
      return true;
    };
  })()
);
var ESCAPED = Null$1({
  ...fromEntries([...Array$1(32)].map((_, charCode) => [fromCharCode(charCode), "\\u" + charCode.toString(16).toUpperCase().padStart(4, "0")])),
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  '"': '\\"',
  '"""': '""\\"',
  "\\": "\\\\",
  "": "\\u007F"
});
var { test: NEED_BASIC } = theRegExp(/[\x00-\x08\x0A-\x1F'\x7F]/);
var BY_ESCAPE = /[^\x00-\x08\x0A-\x1F"\\\x7F]+|./gs;
var { test: NEED_ESCAPE } = theRegExp(/^[\x00-\x08\x0A-\x1F"\\\x7F]/);
var singlelineString = (value) => {
  if (NEED_BASIC(value)) {
    const parts = value.match(BY_ESCAPE);
    let index = parts.length;
    do {
      if (NEED_ESCAPE(parts[--index])) {
        parts[index] = ESCAPED[parts[index]];
      }
    } while (index);
    return `"${parts.join("")}"`;
  }
  return `'${value}'`;
};
var singlelineBasicString = (value) => {
  if (value) {
    const parts = value.match(BY_ESCAPE);
    let index = parts.length;
    do {
      if (NEED_ESCAPE(parts[--index])) {
        parts[index] = ESCAPED[parts[index]];
      }
    } while (index);
    return `"${parts.join("")}"`;
  }
  return `""`;
};
var { test: NEED_MULTILINE_BASIC } = theRegExp(/[\x00-\x08\x0A-\x1F\x7F]|'''/);
var { test: multilineNeedBasic } = theRegExp(/[\x00-\x08\x0B-\x1F\x7F]|'''/);
var { test: REAL_MULTILINE_ESCAPE } = theRegExp(/[\x00-\x08\x0A-\x1F\\\x7F]|"""/);
var BY_MULTILINE_ESCAPE = /[^\x00-\x08\x0A-\x1F"\\\x7F]+|"""|./gs;
var { test: NEED_MULTILINE_ESCAPE } = theRegExp(/^(?:[\x00-\x08\x0A-\x1F\\\x7F]|""")/);
var escape_multiline = (lines, lineIndex2) => {
  const line = lines[lineIndex2];
  if (REAL_MULTILINE_ESCAPE(line)) {
    const parts = line.match(BY_MULTILINE_ESCAPE);
    let index = parts.length;
    do {
      if (NEED_MULTILINE_ESCAPE(parts[--index])) {
        parts[index] = ESCAPED[parts[index]];
      }
    } while (index);
    lines[lineIndex2] = parts.join("");
  }
};
var Lines = (lines) => (lines = ["", ...lines]).length === 1 ? ["", ""] : lines;
var multilineString = (lines) => {
  const lastIndex = lines.length - 1;
  let index = lastIndex;
  do {
    if (NEED_MULTILINE_BASIC(lines[index])) {
      break;
    }
  } while (--index);
  if (index) {
    index = lastIndex;
    escape_multiline(lines, index);
    lines[index] += lines[0] = '"""';
    while (--index) {
      escape_multiline(lines, index);
    }
  } else {
    lines[lastIndex] += lines[0] = "'''";
  }
  return lines;
};
var multilineBasicString = (lines) => {
  let index = lines.length - 1;
  escape_multiline(lines, index);
  lines[index] += lines[0] = '"""';
  while (--index) {
    escape_multiline(lines, index);
  }
  return lines;
};
var multilineLiteralString = (lines) => {
  lines[lines.length - 1] += lines[0] = "'''";
  return lines;
};
var Float64Array$1 = Float64Array;
var Uint8Array$1 = Uint8Array;
var _Infinity = -Infinity;
var { test: INTEGER_LIKE } = theRegExp(/^-?\d+$/);
var ensureFloat = (literal2) => INTEGER_LIKE(literal2) ? literal2 + ".0" : literal2;
var float64Array = new Float64Array$1([NaN$1]);
var uint8Array = new Uint8Array$1(float64Array.buffer);
var NaN_7 = uint8Array[7];
var float = NaN_7 === new Uint8Array$1(new Float64Array$1([-NaN$1]).buffer)[7] ? (value) => value ? value === Infinity ? "inf" : value === _Infinity ? "-inf" : ensureFloat("" + value) : value === value ? is(value, 0) ? "0.0" : "-0.0" : "nan" : (value) => value ? value === Infinity ? "inf" : value === _Infinity ? "-inf" : ensureFloat("" + value) : value === value ? is(value, 0) ? "0.0" : "-0.0" : (float64Array[0] = value, uint8Array[7]) === NaN_7 ? "nan" : "-nan";
var isDate = isPrototypeOf.bind(DATE);
var { test: BARE } = theRegExp(/^[\w-]+$/);
var $Key$ = (key) => BARE(key) ? key : singlelineString(key);
var FIRST = /[^.]+/;
var literalString = (value) => `'${value}'`;
var $Keys = (keys2) => isAmazing(keys2) ? keys2.replace(FIRST, literalString) : keys2 === "null" ? `'null'` : keys2;
var TOMLSection = class extends Array$1 {
  document;
  constructor(document) {
    super();
    this.document = document;
    return this;
  }
  [Symbol$1.toPrimitive]() {
    return this.join(this.document.newline);
  }
  appendNewline() {
    this[this.length] = "";
  }
  set appendLine(source) {
    this[this.length] = source;
  }
  set appendInline(source) {
    this[this.length - 1] += source;
  }
  set appendInlineIf(source) {
    source && (this[this.length - 1] += source);
  }
  ///
  *assignBlock(documentKeys_, sectionKeys_, table, tableKeys) {
    const { document } = this;
    const { newlineUnderHeader, newlineUnderSectionButPair } = document;
    const newlineAfterDotted = sectionKeys_ ? document.newlineUnderPairButDotted : false;
    const newlineAfterPair = sectionKeys_ ? document.newlineUnderDotted : document.newlineUnderPair;
    for (const tableKey of tableKeys) {
      const value = table[tableKey];
      const $key$ = $Key$(tableKey);
      const documentKeys = documentKeys_ + $key$;
      if (isArray$1(value)) {
        const { length } = value;
        if (length) {
          let firstItem = value[0];
          if (isSection(firstItem)) {
            const tableHeader = `[[${documentKeys}]]`;
            const documentKeys_2 = documentKeys + ".";
            let index = 0;
            let table2 = firstItem;
            for (; ; ) {
              const section = document.appendSection();
              section[0] = tableHeader + getCOMMENT(table2, commentForThis);
              if (newlineUnderHeader) {
                section[1] = "";
                yield section.assignBlock(documentKeys_2, ``, table2, getOwnPropertyNames(table2));
                newlineUnderSectionButPair && section.length !== 2 && section.appendNewline();
              } else {
                yield section.assignBlock(documentKeys_2, ``, table2, getOwnPropertyNames(table2));
                newlineUnderSectionButPair && section.appendNewline();
              }
              if (++index === length) {
                break;
              }
              table2 = value[index];
              if (!isSection(table2)) {
                throw TypeError$1(`the first table item marked by Section() means the parent array is an array of tables, which can not include other types or table not marked by Section() any more in the rest items`);
              }
            }
            continue;
          } else {
            let index = 1;
            while (index !== length) {
              if (isSection(value[index++])) {
                throw TypeError$1(`if an array is not array of tables, it can not include any table that marked by Section()`);
              }
            }
          }
        }
      } else {
        if (isSection(value)) {
          const section = document.appendSection();
          section[0] = `[${documentKeys}]${document.preferCommentForThis ? getCOMMENT(value, commentForThis) || getComment(table, tableKey) : getComment(table, tableKey) || getCOMMENT(value, commentForThis)}`;
          if (newlineUnderHeader) {
            section[1] = "";
            yield section.assignBlock(documentKeys + ".", ``, value, getOwnPropertyNames(value));
            newlineUnderSectionButPair && section.length !== 2 && section.appendNewline();
          } else {
            yield section.assignBlock(documentKeys + ".", ``, value, getOwnPropertyNames(value));
            newlineUnderSectionButPair && section.appendNewline();
          }
          continue;
        }
      }
      const sectionKeys = sectionKeys_ + $key$;
      this.appendLine = $Keys(sectionKeys) + " = ";
      const valueKeysIfValueIsDottedTable = this.value("", value, true);
      if (valueKeysIfValueIsDottedTable) {
        --this.length;
        yield this.assignBlock(documentKeys + ".", sectionKeys + ".", value, valueKeysIfValueIsDottedTable);
        newlineAfterDotted && this.appendNewline();
      } else {
        this.appendInlineIf = getComment(table, tableKey);
        newlineAfterPair && this.appendNewline();
      }
    }
  }
  value(indent, value, returnValueKeysIfValueIsDottedTable) {
    switch (typeof value) {
      case "object":
        if (value === null) {
          if (this.document.nullDisabled) {
            throw TypeError$1(`toml can not stringify "null" type value without truthy options.xNull`);
          }
          this.appendInline = "null";
          break;
        }
        const inlineMode = ofInline(value);
        if (isArray$1(value)) {
          if (inlineMode === undefined$1) {
            this.staticArray(indent, value);
          } else {
            const { $singlelineArray = inlineMode } = this.document;
            this.singlelineArray(indent, value, $singlelineArray);
          }
          break;
        }
        if (inlineMode !== undefined$1) {
          inlineMode || this.document.multilineTableDisabled ? this.inlineTable(indent, value) : this.multilineTable(indent, value, this.document.multilineTableComma);
          break;
        }
        if (isDate(value)) {
          this.appendInline = value.toISOString().replace("T", this.document.T).replace("Z", this.document.Z);
          break;
        }
        if (_literal in value) {
          const literal2 = value[_literal];
          if (typeof literal2 === "string") {
            this.appendInline = literal2;
          } else if (isArray$1(literal2)) {
            const { length } = literal2;
            if (length) {
              this.appendInline = literal2[0];
              let index = 1;
              while (index !== length) {
                this.appendLine = literal2[index++];
              }
            } else {
              throw TypeError$1(`literal value is broken`);
            }
          } else {
            throw TypeError$1(`literal value is broken`);
          }
          break;
        }
        if (isString(value)) {
          throw TypeError$1(`TOML.stringify refuse to handle [object String]`);
        }
        if (isNumber(value)) {
          throw TypeError$1(`TOML.stringify refuse to handle [object Number]`);
        }
        if (isBigInt(value)) {
          throw TypeError$1(`TOML.stringify refuse to handle [object BigInt]`);
        }
        if (isBoolean(value)) {
          throw TypeError$1(`TOML.stringify refuse to handle [object Boolean]`);
        }
        if (returnValueKeysIfValueIsDottedTable) {
          const keys2 = getOwnPropertyNames(value);
          if (keys2.length) {
            return keys2;
          }
          this.appendInline = "{ }";
        } else {
          this.inlineTable(indent, value);
        }
        break;
      case "bigint":
        this.appendInline = "" + value;
        break;
      case "number":
        this.appendInline = this.document.asInteger(value) ? is(value, -0) ? "-0" : "" + value : float(value);
        break;
      case "string":
        this.appendInline = singlelineString(value);
        break;
      case "boolean":
        this.appendInline = value ? "true" : "false";
        break;
      default:
        throw TypeError$1(`toml can not stringify "${typeof value}" type value`);
    }
    return null;
  }
  singlelineArray(indent, staticArray, inlineMode) {
    const { length } = staticArray;
    if (length) {
      this.appendInline = inlineMode & 2 ? "[ " : "[";
      this.value(indent, staticArray[0], false);
      let index = 1;
      while (index !== length) {
        this.appendInline = ", ";
        this.value(indent, staticArray[index++], false);
      }
      this.appendInline = inlineMode & 2 ? " ]" : "]";
    } else {
      this.appendInline = inlineMode & 1 ? "[ ]" : "[]";
    }
  }
  staticArray(indent, staticArray) {
    this.appendInline = "[";
    const indent_ = indent + this.document.indent;
    const { length } = staticArray;
    let index = 0;
    while (index !== length) {
      this.appendLine = indent_;
      this.value(indent_, staticArray[index++], false);
      this.appendInline = ",";
    }
    this.appendLine = indent + "]";
  }
  inlineTable(indent, inlineTable2) {
    const keys2 = getOwnPropertyNames(inlineTable2);
    if (keys2.length) {
      this.appendInline = "{ ";
      this.assignInline(indent, inlineTable2, ``, keys2);
      this[this.length - 1] = this[this.length - 1].slice(0, -2) + " }";
    } else {
      this.appendInline = "{ }";
    }
  }
  multilineTable(indent, inlineTable2, comma) {
    this.appendInline = "{";
    this.assignMultiline(indent, inlineTable2, ``, getOwnPropertyNames(inlineTable2), comma);
    this.appendLine = indent + "}";
  }
  assignInline(indent, inlineTable2, keys_, keys2) {
    for (const key of keys2) {
      const value = inlineTable2[key];
      const keys3 = keys_ + $Key$(key);
      const before_value = this.appendInline = $Keys(keys3) + " = ";
      const valueKeysIfValueIsDottedTable = this.value(indent, value, true);
      if (valueKeysIfValueIsDottedTable) {
        this[this.length - 1] = this[this.length - 1].slice(0, -before_value.length);
        this.assignInline(indent, value, keys3 + ".", valueKeysIfValueIsDottedTable);
      } else {
        this.appendInline = ", ";
      }
    }
  }
  assignMultiline(indent, inlineTable2, keys_, keys2, comma) {
    const indent_ = indent + this.document.indent;
    for (const key of keys2) {
      const value = inlineTable2[key];
      const keys3 = keys_ + $Key$(key);
      this.appendLine = indent_ + $Keys(keys3) + " = ";
      const valueKeysIfValueIsDottedTable = this.value(indent_, value, true);
      if (valueKeysIfValueIsDottedTable) {
        --this.length;
        this.assignMultiline(indent, value, keys3 + ".", valueKeysIfValueIsDottedTable, comma);
      } else {
        comma ? this.appendInline = "," + getComment(inlineTable2, key) : this.appendInlineIf = getComment(inlineTable2, key);
      }
    }
  }
};
var name2code = Null$1({
  document: 0,
  section: 1,
  header: 2,
  pairs: 3,
  pair: 4
});
var { test: IS_INDENT } = theRegExp(/^[\t ]*$/);
var return_false = () => false;
var TOMLDocument = class extends Array$1 {
  get ["constructor"]() {
    return Array$1;
  }
  0 = new TOMLSection(this);
  asInteger = return_false;
  newline = "";
  newlineUnderSection = true;
  newlineUnderSectionButPair = true;
  newlineUnderHeader = true;
  newlineUnderPair = false;
  newlineUnderPairButDotted = false;
  newlineUnderDotted = false;
  indent = "	";
  T = "T";
  Z = "Z";
  nullDisabled = true;
  multilineTableDisabled = true;
  multilineTableComma;
  preferCommentForThis = false;
  $singlelineArray;
  constructor(options) {
    super();
    if (options == null) {
      return this;
    }
    const { integer } = options;
    if (integer === void 0) ;
    else if (integer === MAX_SAFE_INTEGER) {
      this.asInteger = isSafeInteger;
    } else if (typeof integer === "number") {
      if (!isSafeInteger(integer)) {
        throw RangeError$1(`TOML.stringify(,{integer}) can only be a safe integer`);
      }
      const max = integer >= 0 ? integer : -integer - 1;
      const min = integer >= 0 ? -integer : integer;
      this.asInteger = (number) => isSafeInteger(number) && min <= number && number <= max;
    } else {
      throw TypeError$1(`TOML.stringify(,{integer}) can only be number`);
    }
    const { newline } = options;
    if (newline === void 0) ;
    else if (newline === "\n" || newline === "\r\n") {
      this.newline = newline;
    } else {
      throw typeof newline === "string" ? SyntaxError$1(`TOML.stringify(,{newline}) can only be valid TOML newline`) : TypeError$1(`TOML.stringify(,{newline}) can only be string`);
    }
    const { preferCommentFor } = options;
    if (preferCommentFor === void 0) ;
    else if (preferCommentFor === "this" || preferCommentFor === "key") {
      this.preferCommentForThis = preferCommentFor === "this";
    } else {
      throw TypeError$1(`TOML.stringify(,{preferCommentFor) can only be 'key' or 'this'`);
    }
    const { [options.newlineAround || "header"]: around = name2code.header } = name2code;
    this.newlineUnderSection = around > 0;
    this.newlineUnderSectionButPair = around === 1 || around === 2;
    this.newlineUnderHeader = around > 1;
    this.newlineUnderPair = around > 2;
    this.newlineUnderPairButDotted = around === 3;
    this.newlineUnderDotted = around > 3;
    const { indent } = options;
    if (indent === void 0) ;
    else if (typeof indent === "string") {
      if (!IS_INDENT(indent)) {
        throw SyntaxError$1(`TOML.stringify(,{indent}) can only include Tab or Space`);
      }
      this.indent = indent;
    } else if (typeof indent === "number") {
      if (!isSafeInteger(indent)) {
        throw RangeError$1(`TOML.stringify(,{indent:${indent}}) is out of range`);
      }
      this.indent = " ".repeat(indent);
    } else {
      throw TypeError$1(`TOML.stringify(,{indent}) can not be "${typeof indent}" type`);
    }
    const { T: T2 } = options;
    if (T2 === void 0) ;
    else if (T2 === " " || T2 === "t" || T2 === "T") {
      this.T = T2;
    } else {
      throw TypeError$1(`TOML.stringify(,{T}) can only be "T" or " " or "t"`);
    }
    const { Z } = options;
    if (Z === void 0) ;
    else if (Z === "z" || Z === "Z") {
      this.Z = Z;
    } else {
      throw TypeError$1(`TOML.stringify(,{Z}) can only be "Z" or "z"`);
    }
    if (options.xNull) {
      this.nullDisabled = false;
    }
    const { xBeforeNewlineInMultilineTable } = options;
    if (xBeforeNewlineInMultilineTable === void 0) ;
    else if (xBeforeNewlineInMultilineTable === "" || xBeforeNewlineInMultilineTable === ",") {
      this.multilineTableDisabled = false;
      this.multilineTableComma = !!xBeforeNewlineInMultilineTable;
    } else {
      throw TypeError$1(`TOML.stringify(,{xBeforeNewlineInMultilineTable}) can only be "" or ","`);
    }
    const $singlelineArray = options.forceInlineArraySpacing;
    switch ($singlelineArray) {
      case void 0:
        break;
      case 0:
      case 1:
      case 2:
      case 3:
        this.$singlelineArray = $singlelineArray;
        break;
      default:
        throw typeof $singlelineArray === "number" ? RangeError$1(`array inline mode must be 0 | 1 | 2 | 3, not including ${$singlelineArray}`) : TypeError$1(`array inline mode must be "number" type, not including ${$singlelineArray === null ? '"null"' : typeof $singlelineArray}`);
    }
    return this;
  }
  appendSection() {
    return this[this.length] = new TOMLSection(this);
  }
};
var linesFromStringify = new WeakSet$1();
var beLinesFromStringify = add.bind(linesFromStringify);
var isLinesFromStringify = has.bind(linesFromStringify);
var stringify = (rootTable, options) => {
  const document = new TOMLDocument(options);
  const section = document[0];
  section[0] = "";
  x(section.assignBlock(``, ``, rootTable, getOwnPropertyNames(rootTable)));
  document.newlineUnderSectionButPair && section.length !== 1 && section.appendNewline();
  document.newlineUnderSection || document[document.length - 1].appendNewline();
  if (document.newline) {
    return document.join(document.newline);
  }
  const lines = document.flat();
  beLinesFromStringify(lines);
  return lines;
};
var multiline = (() => {
  const multiline2 = (value, string) => typeof value === "string" ? LiteralObject((multilineNeedBasic(value) ? multilineBasicString : multilineLiteralString)(("\n" + value).split("\n")), value) : isArray$1(value) ? LiteralObject(multilineString(Lines(value)), typeof string === "string" ? string : Null$1(null)) : multilineTable(value);
  multiline2.basic = (lines, string) => typeof lines === "string" ? LiteralObject(multilineBasicString(("\n" + lines).split("\n")), lines) : LiteralObject(multilineBasicString(Lines(lines)), typeof string === "string" ? string : Null$1(null));
  multiline2.array = multilineArray;
  freeze(multiline2);
  return multiline2;
})();
var basic = (value) => LiteralObject(singlelineBasicString(value), value);
var literal = (literal2, ...chars) => {
  if (typeof literal2 === "string") {
    if (chars.length === 1) {
      return LiteralObject(literal2.includes("\n") ? literal2.split("\n") : literal2, chars[0]);
    }
  } else {
    let index = chars.length;
    if (index) {
      const { raw } = literal2;
      literal2 = raw[index];
      while (index) {
        chars[--index] += raw[index];
      }
      literal2 = chars.join("") + literal2;
    } else {
      literal2 = literal2.raw[0];
    }
  }
  return LiteralObject(literal2.includes("\n") ? literal2.split("\n") : literal2, Null$1(null));
};
var textDecoder = new TextDecoder$1("utf-8", Null$1({ fatal: true, ignoreBOM: false }));
var binary2string = (arrayBufferLike) => {
  if (isView(arrayBufferLike) ? arrayBufferLike.length !== arrayBufferLike.byteLength : !isArrayBuffer(arrayBufferLike)) {
    throw TypeError$1(`only Uint8Array or ArrayBuffer is acceptable`);
  }
  try {
    return textDecoder.decode(arrayBufferLike);
  } catch {
    throw Error$1(`A TOML doc must be a (ful-scalar) valid UTF-8 file, without any unknown code point.`);
  }
};
var isBinaryLike = (value) => "byteLength" in value;
var { test: includesNonScalar } = theRegExp(/[\uD800-\uDFFF]/u);
var assertFulScalar = (string) => {
  if (clearRegExp$1(includesNonScalar(string))) {
    throw Error$1(`A TOML doc must be a (ful-scalar) valid UTF-8 file, without any uncoupled UCS-4 character code.`);
  }
};
var holding = false;
var parse = (source, specificationVersion, multilineStringJoiner, bigint, x2, argsMode) => {
  let sourcePath2 = "";
  if (typeof source === "object" && source) {
    if (isArray$1(source)) {
      throw TypeError$1(isLinesFromStringify(source) ? `TOML.parse(array from TOML.stringify(,{newline?}))` : `TOML.parse(array)`);
    } else if (isBinaryLike(source)) {
      source = binary2string(source);
    } else {
      sourcePath2 = source.path;
      if (typeof sourcePath2 !== "string") {
        throw TypeError$1(`TOML.parse(source.path)`);
      }
      const { data, require: req = typeof __require === "function" ? __require : undefined$1 } = source;
      if (req) {
        const { resolve } = req;
        if (resolve != null) {
          const { paths } = resolve;
          if (paths != null) {
            const ret = apply$1(paths, resolve, [""]);
            if (ret != null) {
              const val = ret[0];
              if (val != null) {
                const dirname_ = val.replace(/node_modules$/, "");
                if (dirname_) {
                  sourcePath2 = req("path").resolve(dirname_, sourcePath2);
                  if (typeof sourcePath2 !== "string") {
                    throw TypeError$1(`TOML.parse(source.require('path').resolve)`);
                  }
                }
              }
            }
          }
        }
        if (data === undefined$1) {
          const data2 = req("fs").readFileSync(sourcePath2);
          if (typeof data2 === "object" && data2 && isBinaryLike(data2)) {
            source = binary2string(data2);
          } else {
            throw TypeError$1(`TOML.parse(source.require('fs').readFileSync)`);
          }
        } else if (typeof data === "string") {
          assertFulScalar(source = data);
        } else if (typeof data === "object" && data && isBinaryLike(data)) {
          source = binary2string(data);
        } else {
          throw TypeError$1(`TOML.parse(source.data)`);
        }
      } else {
        if (data === undefined$1) {
          throw TypeError$1(`TOML.parse(source.data|source.require)`);
        } else if (typeof data === "string") {
          assertFulScalar(source = data);
        } else if (typeof data === "object" && data && isBinaryLike(data)) {
          source = binary2string(data);
        } else {
          throw TypeError$1(`TOML.parse(source.data)`);
        }
      }
    }
  } else if (typeof source === "string") {
    assertFulScalar(source);
  } else {
    throw TypeError$1(`TOML.parse(source)`);
  }
  let joiner;
  let keys2;
  if (typeof multilineStringJoiner === "object" && multilineStringJoiner) {
    if (bigint !== undefined$1 || x2 !== undefined$1) {
      throw TypeError$1(`options mode ? args mode`);
    }
    joiner = multilineStringJoiner.joiner;
    bigint = multilineStringJoiner.bigint;
    keys2 = multilineStringJoiner.keys;
    x2 = multilineStringJoiner.x;
    argsMode = "";
  } else {
    joiner = multilineStringJoiner;
  }
  let rootTable;
  let process;
  if (holding) {
    throw Error$1(`parsing during parsing.`);
  }
  holding = true;
  try {
    use(specificationVersion, joiner, bigint, keys2, x2, argsMode);
    todo(source, sourcePath2);
    source && source[0] === "\uFEFF" && throws(TypeError$1(`TOML content (string) should not start with BOM (U+FEFF)` + where(" at ")));
    rootTable = Root();
    process = Process();
  } finally {
    done();
    clear();
    holding = false;
    clearRegExp$1();
  }
  process && process();
  return rootTable;
};
var parse$1 = assign$1(
  (source, specificationVersion, multilineStringJoiner, useBigInt, xOptions) => typeof specificationVersion === "number" ? parse(source, specificationVersion, multilineStringJoiner, useBigInt, xOptions, ",,") : parse(source, 1, specificationVersion, multilineStringJoiner, useBigInt, ","),
  {
    "1.0": (source, multilineStringJoiner, useBigInt, xOptions) => parse(source, 0.1, multilineStringJoiner, useBigInt, xOptions, ","),
    1: (source, multilineStringJoiner, useBigInt, xOptions) => parse(source, 1, multilineStringJoiner, useBigInt, xOptions, ","),
    0.5: (source, multilineStringJoiner, useBigInt, xOptions) => parse(source, 0.5, multilineStringJoiner, useBigInt, xOptions, ","),
    0.4: (source, multilineStringJoiner, useBigInt, xOptions) => parse(source, 0.4, multilineStringJoiner, useBigInt, xOptions, ","),
    0.3: (source, multilineStringJoiner, useBigInt, xOptions) => parse(source, 0.3, multilineStringJoiner, useBigInt, xOptions, ","),
    0.2: (source, multilineStringJoiner, useBigInt, xOptions) => parse(source, 0.2, multilineStringJoiner, useBigInt, xOptions, ","),
    0.1: (source, multilineStringJoiner, useBigInt, xOptions) => parse(source, 0.1, multilineStringJoiner, useBigInt, xOptions, ",")
  }
);
var _export = Default({
  version,
  parse: parse$1,
  stringify,
  Section,
  inline,
  multiline,
  basic,
  literal,
  commentFor,
  commentForThis,
  OffsetDateTime,
  LocalDateTime,
  LocalDate,
  LocalTime,
  isInline,
  isSection,
  Keys
});
export {
  Keys,
  LocalDate,
  LocalDateTime,
  LocalTime,
  OffsetDateTime,
  Section,
  basic,
  commentFor,
  commentForThis,
  _export as default,
  inline,
  isInline,
  isSection,
  literal,
  multiline,
  parse$1 as parse,
  stringify,
  version
};
/*! Bundled license information:

@ltd/j-toml/index.mjs:
  (*!@preserve@license
   * 模块名称：j-regexp
   * 模块功能：可读性更好的正则表达式创建方式。从属于“简计划”。
     　　　　　More readable way for creating RegExp. Belong to "Plan J".
   * 模块版本：8.2.0
   * 许可条款：LGPL-3.0
   * 所属作者：龙腾道 <LongTengDao@LongTengDao.com> (www.LongTengDao.com)
   * 问题反馈：https://GitHub.com/LongTengDao/j-regexp/issues
   * 项目主页：https://GitHub.com/LongTengDao/j-regexp/
   *)
  (*!@preserve@license
   * 模块名称：j-orderify
   * 模块功能：返回一个能保证给定对象的属性按此后添加顺序排列的 proxy，即使键名是 symbol，或整数 string。从属于“简计划”。
     　　　　　Return a proxy for given object, which can guarantee own keys are in setting order, even if the key name is symbol or int string. Belong to "Plan J".
   * 模块版本：7.0.1
   * 许可条款：LGPL-3.0
   * 所属作者：龙腾道 <LongTengDao@LongTengDao.com> (www.LongTengDao.com)
   * 问题反馈：https://GitHub.com/LongTengDao/j-orderify/issues
   * 项目主页：https://GitHub.com/LongTengDao/j-orderify/
   *)
*/
//# sourceMappingURL=@ltd_j-toml.js.map
